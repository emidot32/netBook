"use strict";
const sinon = require("sinon");
const lib_1 = require("../lib");
const docker_1 = require("../lib/docker");
const os = require("../lib/os");
const mock_sdk_1 = require("./util/mock-sdk");
module.exports = {
    async 'creates repository with given name'(test) {
        // GIVEN
        let createdName;
        const sdk = new mock_sdk_1.MockSDK();
        sdk.stubEcr({
            describeRepositories() {
                return { repositories: [] };
            },
            createRepository(req) {
                createdName = req.repositoryName;
                // Stop the test so that we don't actually docker build
                throw new Error('STOPTEST');
            },
        });
        const toolkit = new lib_1.ToolkitInfo({
            sdk,
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            repositoryName: 'some-name',
            sourceHash: '0123456789abcdef',
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        test.deepEqual(createdName, 'some-name');
        test.done();
    },
    async 'derives repository name from asset id'(test) {
        // GIVEN
        let createdName;
        const sdk = new mock_sdk_1.MockSDK();
        sdk.stubEcr({
            describeRepositories() {
                return { repositories: [] };
            },
            createRepository(req) {
                createdName = req.repositoryName;
                // Stop the test so that we don't actually docker build
                throw new Error('STOPTEST');
            },
        });
        const toolkit = new lib_1.ToolkitInfo({
            sdk,
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        // WHEN
        const asset = {
            id: 'Stack:Construct/ABC123',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            sourceHash: '0123456789abcdef',
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        test.deepEqual(createdName, 'cdk/stack-construct-abc123');
        test.done();
    },
    async 'configures lifecycle policy and image scanning'(test) {
        // GIVEN
        let putLifecyclePolicyParams;
        let putImageScanningConfigurationParams;
        const sdk = new mock_sdk_1.MockSDK();
        sdk.stubEcr({
            describeRepositories() {
                return { repositories: [] };
            },
            createRepository() {
                return {
                    repository: {
                        repositoryUri: 'uri'
                    }
                };
            },
            putLifecyclePolicy(params) {
                putLifecyclePolicyParams = params;
                return {};
            },
            putImageScanningConfiguration(params) {
                putImageScanningConfigurationParams = params;
                // Stop the test so that we don't actually docker build
                throw new Error('STOPTEST');
            }
        });
        const toolkit = new lib_1.ToolkitInfo({
            sdk,
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            repositoryName: 'some-name',
            sourceHash: '0123456789abcdef',
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        test.deepEqual(putLifecyclePolicyParams, {
            repositoryName: 'some-name',
            lifecyclePolicyText: JSON.stringify(lib_1.DEFAULT_REPO_LIFECYCLE)
        });
        test.deepEqual(putImageScanningConfigurationParams, {
            repositoryName: 'some-name',
            imageScanningConfiguration: {
                scanOnPush: true
            }
        });
        test.done();
    },
    async 'passes the correct target to docker build'(test) {
        // GIVEN
        const toolkit = new lib_1.ToolkitInfo({
            sdk: new mock_sdk_1.MockSDK(),
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
            repositoryUri: 'uri',
            repositoryName: 'name'
        });
        const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            sourceHash: '1234567890abcdef',
            repositoryName: 'some-name',
            buildArgs: {
                a: 'b',
                c: 'd'
            },
            target: 'a-target',
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/foo', '--target', 'a-target'];
        test.ok(shellStub.calledWith(command));
        prepareEcrRepositoryStub.restore();
        shellStub.restore();
        test.done();
    },
    async 'passes the correct args to docker build'(test) {
        // GIVEN
        const toolkit = new lib_1.ToolkitInfo({
            sdk: new mock_sdk_1.MockSDK(),
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
            repositoryUri: 'uri',
            repositoryName: 'name'
        });
        const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            sourceHash: '1234567890abcdef',
            repositoryName: 'some-name',
            buildArgs: {
                a: 'b',
                c: 'd'
            }
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/foo'];
        test.ok(shellStub.calledWith(command));
        prepareEcrRepositoryStub.restore();
        shellStub.restore();
        test.done();
    },
    async 'relative path'(test) {
        // GIVEN
        const toolkit = new lib_1.ToolkitInfo({
            sdk: new mock_sdk_1.MockSDK(),
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
            repositoryUri: 'uri',
            repositoryName: 'name'
        });
        const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: 'relative-to-assembly',
            sourceHash: '1234567890abcdef',
            repositoryName: 'some-name',
            buildArgs: {
                a: 'b',
                c: 'd'
            }
        };
        try {
            await docker_1.prepareContainerAsset('/assembly/dir/root', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/assembly/dir/root/relative-to-assembly'];
        test.ok(shellStub.calledWith(command));
        prepareEcrRepositoryStub.restore();
        shellStub.restore();
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5kb2NrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LmRvY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsK0JBQWdDO0FBQ2hDLGdDQUE2RDtBQUM3RCwwQ0FBc0Q7QUFDdEQsZ0NBQWlDO0FBQ2pDLDhDQUEwQztBQUUxQyxpQkFBUztJQUNQLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxJQUFVO1FBQ25ELFFBQVE7UUFFUixJQUFJLFdBQVcsQ0FBQztRQUVoQixNQUFNLEdBQUcsR0FBRyxJQUFJLGtCQUFPLEVBQUUsQ0FBQztRQUMxQixHQUFHLENBQUMsT0FBTyxDQUFDO1lBQ1Ysb0JBQW9CO2dCQUNsQixPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQzlCLENBQUM7WUFFRCxnQkFBZ0IsQ0FBQyxHQUFHO2dCQUNsQixXQUFXLEdBQUcsR0FBRyxDQUFDLGNBQWMsQ0FBQztnQkFFakMsdURBQXVEO2dCQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlCLENBQUM7U0FDRixDQUFDLENBQUM7UUFFSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGlCQUFXLENBQUM7WUFDOUIsR0FBRztZQUNILFVBQVUsRUFBRSxhQUFhO1lBQ3pCLGNBQWMsRUFBRSxpQkFBaUI7WUFDakMsV0FBVyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7U0FDN0QsQ0FBQyxDQUFDO1FBRUgsT0FBTztRQUNQLE1BQU0sS0FBSyxHQUEyQztZQUNwRCxFQUFFLEVBQUUsU0FBUztZQUNiLGtCQUFrQixFQUFFLGFBQWE7WUFDakMsU0FBUyxFQUFFLGlCQUFpQjtZQUM1QixJQUFJLEVBQUUsTUFBTTtZQUNaLGNBQWMsRUFBRSxXQUFXO1lBQzNCLFVBQVUsRUFBRSxrQkFBa0I7U0FDL0IsQ0FBQztRQUVGLElBQUk7WUFDRixNQUFNLDhC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cEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5pbXBvcnQgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xuaW1wb3J0IHsgREVGQVVMVF9SRVBPX0xJRkVDWUNMRSwgVG9vbGtpdEluZm8gfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgcHJlcGFyZUNvbnRhaW5lckFzc2V0IH0gZnJvbSAnLi4vbGliL2RvY2tlcic7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCcuLi9saWIvb3MnKTtcbmltcG9ydCB7IE1vY2tTREsgfSBmcm9tICcuL3V0aWwvbW9jay1zZGsnO1xuXG5leHBvcnQgPSB7XG4gIGFzeW5jICdjcmVhdGVzIHJlcG9zaXRvcnkgd2l0aCBnaXZlbiBuYW1lJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cblxuICAgIGxldCBjcmVhdGVkTmFtZTtcblxuICAgIGNvbnN0IHNkayA9IG5ldyBNb2NrU0RLKCk7XG4gICAgc2RrLnN0dWJFY3Ioe1xuICAgICAgZGVzY3JpYmVSZXBvc2l0b3JpZXMoKSB7XG4gICAgICAgIHJldHVybiB7IHJlcG9zaXRvcmllczogW10gfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZVJlcG9zaXRvcnkocmVxKSB7XG4gICAgICAgIGNyZWF0ZWROYW1lID0gcmVxLnJlcG9zaXRvcnlOYW1lO1xuXG4gICAgICAgIC8vIFN0b3AgdGhlIHRlc3Qgc28gdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBkb2NrZXIgYnVpbGRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVE9QVEVTVCcpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgICBpbWFnZU5hbWVQYXJhbWV0ZXI6ICdNeVBhcmFtZXRlcicsXG4gICAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgICAgcGF0aDogJy9mb28nLFxuICAgICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgICAgc291cmNlSGFzaDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBUSEVOXG4gICAgdGVzdC5kZWVwRXF1YWwoY3JlYXRlZE5hbWUsICdzb21lLW5hbWUnKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIGFzeW5jICdkZXJpdmVzIHJlcG9zaXRvcnkgbmFtZSBmcm9tIGFzc2V0IGlkJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cblxuICAgIGxldCBjcmVhdGVkTmFtZTtcblxuICAgIGNvbnN0IHNkayA9IG5ldyBNb2NrU0RLKCk7XG4gICAgc2RrLnN0dWJFY3Ioe1xuICAgICAgZGVzY3JpYmVSZXBvc2l0b3JpZXMoKSB7XG4gICAgICAgIHJldHVybiB7IHJlcG9zaXRvcmllczogW10gfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZVJlcG9zaXRvcnkocmVxKSB7XG4gICAgICAgIGNyZWF0ZWROYW1lID0gcmVxLnJlcG9zaXRvcnlOYW1lO1xuXG4gICAgICAgIC8vIFN0b3AgdGhlIHRlc3Qgc28gdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBkb2NrZXIgYnVpbGRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVE9QVEVTVCcpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICAgIGlkOiAnU3RhY2s6Q29uc3RydWN0L0FCQzEyMycsXG4gICAgICBpbWFnZU5hbWVQYXJhbWV0ZXI6ICdNeVBhcmFtZXRlcicsXG4gICAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgICAgcGF0aDogJy9mb28nLFxuICAgICAgc291cmNlSGFzaDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBUSEVOXG4gICAgdGVzdC5kZWVwRXF1YWwoY3JlYXRlZE5hbWUsICdjZGsvc3RhY2stY29uc3RydWN0LWFiYzEyMycpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgYXN5bmMgJ2NvbmZpZ3VyZXMgbGlmZWN5Y2xlIHBvbGljeSBhbmQgaW1hZ2Ugc2Nhbm5pbmcnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGxldCBwdXRMaWZlY3ljbGVQb2xpY3lQYXJhbXM7XG4gICAgbGV0IHB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uUGFyYW1zO1xuXG4gICAgY29uc3Qgc2RrID0gbmV3IE1vY2tTREsoKTtcbiAgICBzZGsuc3R1YkVjcih7XG4gICAgICBkZXNjcmliZVJlcG9zaXRvcmllcygpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVwb3NpdG9yaWVzOiBbXSB9O1xuICAgICAgfSxcblxuICAgICAgY3JlYXRlUmVwb3NpdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXBvc2l0b3J5OiB7XG4gICAgICAgICAgICByZXBvc2l0b3J5VXJpOiAndXJpJ1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHB1dExpZmVjeWNsZVBvbGljeShwYXJhbXMpIHtcbiAgICAgICAgcHV0TGlmZWN5Y2xlUG9saWN5UGFyYW1zID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuXG4gICAgICBwdXRJbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb25QYXJhbXMgPSBwYXJhbXM7XG5cbiAgICAgICAgLy8gU3RvcCB0aGUgdGVzdCBzbyB0aGF0IHdlIGRvbid0IGFjdHVhbGx5IGRvY2tlciBidWlsZFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NUT1BURVNUJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b29sa2l0ID0gbmV3IFRvb2xraXRJbmZvKHtcbiAgICAgIHNkayxcbiAgICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgICBidWNrZXRFbmRwb2ludDogJ0JVQ0tFVF9FTkRQT0lOVCcsXG4gICAgICBlbnZpcm9ubWVudDogeyBuYW1lOiAnZW52JywgYWNjb3VudDogJzEyMzQnLCByZWdpb246ICdhYmMnIH1cbiAgICB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBhc3NldDogY3hhcGkuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgPSB7XG4gICAgICBpZDogJ2Fzc2V0SWQnLFxuICAgICAgaW1hZ2VOYW1lUGFyYW1ldGVyOiAnTXlQYXJhbWV0ZXInLFxuICAgICAgcGFja2FnaW5nOiAnY29udGFpbmVyLWltYWdlJyxcbiAgICAgIHBhdGg6ICcvZm9vJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnc29tZS1uYW1lJyxcbiAgICAgIHNvdXJjZUhhc2g6ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByZXBhcmVDb250YWluZXJBc3NldCgnLicsIGFzc2V0LCB0b29sa2l0LCBmYWxzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgLy8gVEhFTlxuICAgIHRlc3QuZGVlcEVxdWFsKHB1dExpZmVjeWNsZVBvbGljeVBhcmFtcywge1xuICAgICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgICAgbGlmZWN5Y2xlUG9saWN5VGV4dDogSlNPTi5zdHJpbmdpZnkoREVGQVVMVF9SRVBPX0xJRkVDWUNMRSlcbiAgICB9KTtcblxuICAgIHRlc3QuZGVlcEVxdWFsKHB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uUGFyYW1zLCB7XG4gICAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgICBpbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICBzY2FuT25QdXNoOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICBhc3luYyAncGFzc2VzIHRoZSBjb3JyZWN0IHRhcmdldCB0byBkb2NrZXIgYnVpbGQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrOiBuZXcgTW9ja1NESygpLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViID0gc2lub24uc3R1Yih0b29sa2l0LCAncHJlcGFyZUVjclJlcG9zaXRvcnknKS5yZXNvbHZlcyh7XG4gICAgICByZXBvc2l0b3J5VXJpOiAndXJpJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnbmFtZSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHNoZWxsU3R1YiA9IHNpbm9uLnN0dWIob3MsICdzaGVsbCcpLnJlamVjdHMoJ1NUT1BURVNUJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgICAgaWQ6ICdhc3NldElkJyxcbiAgICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgICBwYXRoOiAnL2ZvbycsXG4gICAgICBzb3VyY2VIYXNoOiAnMTIzNDU2Nzg5MGFiY2RlZicsXG4gICAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgICBidWlsZEFyZ3M6IHtcbiAgICAgICAgYTogJ2InLFxuICAgICAgICBjOiAnZCdcbiAgICAgIH0sXG4gICAgICB0YXJnZXQ6ICdhLXRhcmdldCcsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcmVwYXJlQ29udGFpbmVyQXNzZXQoJy4nLCBhc3NldCwgdG9vbGtpdCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBUSEVOXG4gICAgY29uc3QgY29tbWFuZCA9IFsnZG9ja2VyJywgJ2J1aWxkJywgJy0tYnVpbGQtYXJnJywgJ2E9YicsICctLWJ1aWxkLWFyZycsICdjPWQnLCAnLS10YWcnLCBgdXJpOmxhdGVzdGAsICcvZm9vJywgJy0tdGFyZ2V0JywgJ2EtdGFyZ2V0J107XG4gICAgdGVzdC5vayhzaGVsbFN0dWIuY2FsbGVkV2l0aChjb21tYW5kKSk7XG5cbiAgICBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIucmVzdG9yZSgpO1xuICAgIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgYXN5bmMgJ3Bhc3NlcyB0aGUgY29ycmVjdCBhcmdzIHRvIGRvY2tlciBidWlsZCcodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3QgdG9vbGtpdCA9IG5ldyBUb29sa2l0SW5mbyh7XG4gICAgICBzZGs6IG5ldyBNb2NrU0RLKCksXG4gICAgICBidWNrZXROYW1lOiAnQlVDS0VUX05BTUUnLFxuICAgICAgYnVja2V0RW5kcG9pbnQ6ICdCVUNLRVRfRU5EUE9JTlQnLFxuICAgICAgZW52aXJvbm1lbnQ6IHsgbmFtZTogJ2VudicsIGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAnYWJjJyB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIgPSBzaW5vbi5zdHViKHRvb2xraXQsICdwcmVwYXJlRWNyUmVwb3NpdG9yeScpLnJlc29sdmVzKHtcbiAgICAgIHJlcG9zaXRvcnlVcmk6ICd1cmknLFxuICAgICAgcmVwb3NpdG9yeU5hbWU6ICduYW1lJ1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2hlbGxTdHViID0gc2lub24uc3R1YihvcywgJ3NoZWxsJykucmVqZWN0cygnU1RPUFRFU1QnKTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBhc3NldDogY3hhcGkuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgPSB7XG4gICAgICBpZDogJ2Fzc2V0SWQnLFxuICAgICAgaW1hZ2VOYW1lUGFyYW1ldGVyOiAnTXlQYXJhbWV0ZXInLFxuICAgICAgcGFja2FnaW5nOiAnY29udGFpbmVyLWltYWdlJyxcbiAgICAgIHBhdGg6ICcvZm9vJyxcbiAgICAgIHNvdXJjZUhhc2g6ICcxMjM0NTY3ODkwYWJjZGVmJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnc29tZS1uYW1lJyxcbiAgICAgIGJ1aWxkQXJnczoge1xuICAgICAgICBhOiAnYicsXG4gICAgICAgIGM6ICdkJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBUSEVOXG4gICAgY29uc3QgY29tbWFuZCA9IFsnZG9ja2VyJywgJ2J1aWxkJywgJy0tYnVpbGQtYXJnJywgJ2E9YicsICctLWJ1aWxkLWFyZycsICdjPWQnLCAnLS10YWcnLCBgdXJpOmxhdGVzdGAsICcvZm9vJ107XG4gICAgdGVzdC5vayhzaGVsbFN0dWIuY2FsbGVkV2l0aChjb21tYW5kKSk7XG5cbiAgICBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIucmVzdG9yZSgpO1xuICAgIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgYXN5bmMgJ3JlbGF0aXZlIHBhdGgnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrOiBuZXcgTW9ja1NESygpLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViID0gc2lub24uc3R1Yih0b29sa2l0LCAncHJlcGFyZUVjclJlcG9zaXRvcnknKS5yZXNvbHZlcyh7XG4gICAgICByZXBvc2l0b3J5VXJpOiAndXJpJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnbmFtZSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHNoZWxsU3R1YiA9IHNpbm9uLnN0dWIob3MsICdzaGVsbCcpLnJlamVjdHMoJ1NUT1BURVNUJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgICAgaWQ6ICdhc3NldElkJyxcbiAgICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgICBwYXRoOiAncmVsYXRpdmUtdG8tYXNzZW1ibHknLFxuICAgICAgc291cmNlSGFzaDogJzEyMzQ1Njc4OTBhYmNkZWYnLFxuICAgICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgICAgYnVpbGRBcmdzOiB7XG4gICAgICAgIGE6ICdiJyxcbiAgICAgICAgYzogJ2QnXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcmVwYXJlQ29udGFpbmVyQXNzZXQoJy9hc3NlbWJseS9kaXIvcm9vdCcsIGFzc2V0LCB0b29sa2l0LCBmYWxzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgLy8gVEhFTlxuICAgIGNvbnN0IGNvbW1hbmQgPSBbJ2RvY2tlcicsICdidWlsZCcsICctLWJ1aWxkLWFyZycsICdhPWInLCAnLS1idWlsZC1hcmcnLCAnYz1kJywgJy0tdGFnJywgYHVyaTpsYXRlc3RgLCAnL2Fzc2VtYmx5L2Rpci9yb290L3JlbGF0aXZlLXRvLWFzc2VtYmx5J107XG4gICAgdGVzdC5vayhzaGVsbFN0dWIuY2FsbGVkV2l0aChjb21tYW5kKSk7XG5cbiAgICBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIucmVzdG9yZSgpO1xuICAgIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH1cbn07XG4iXX0=