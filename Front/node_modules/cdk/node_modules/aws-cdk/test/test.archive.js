"use strict";
const child_process_1 = require("child_process");
const fs = require("fs-extra");
const jszip = require("jszip");
const os = require("os");
const path = require("path");
const util_1 = require("util");
const archive_1 = require("../lib/archive");
const exec = util_1.promisify(child_process_1.exec);
module.exports = {
    async 'zipDirectory can take a directory and produce a zip from it'(test) {
        const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
        const zipFile = path.join(stagingDir, 'output.zip');
        const originalDir = path.join(__dirname, 'test-archive');
        const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.extract'));
        await archive_1.zipDirectory(originalDir, zipFile);
        // unzip and verify that the resulting tree is the same
        await exec(`unzip ${zipFile}`, { cwd: extractDir });
        try {
            await exec(`diff -bur ${originalDir} ${extractDir}`);
        }
        catch (e) {
            test.ok(false, `extracted directory ${extractDir} differs from original ${originalDir}`);
        }
        // inspect the zile file to check that dates are reset
        const zip = await fs.readFile(zipFile);
        const zipData = await jszip.loadAsync(zip);
        const dates = Object.values(zipData.files).map(file => file.date.toISOString());
        test.equal(dates[0], '1980-01-01T00:00:00.000Z', 'Dates are not reset');
        test.equal(new Set(dates).size, 1, 'Dates are not equal');
        // check that mode is preserved
        const stat = await fs.stat(path.join(extractDir, 'executable.txt'));
        // tslint:disable-next-line:no-bitwise
        const isExec = (stat.mode & fs.constants.S_IXUSR) || (stat.mode & fs.constants.S_IXGRP) || (stat.mode & fs.constants.S_IXOTH);
        test.ok(isExec, 'File is not executable');
        await fs.remove(stagingDir);
        await fs.remove(extractDir);
        test.done();
    },
    async 'md5 hash of a zip stays consistent across invocations'(test) {
        const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
        const zipFile1 = path.join(stagingDir, 'output.zip');
        const zipFile2 = path.join(stagingDir, 'output.zip');
        const originalDir = path.join(__dirname, 'test-archive');
        await archive_1.zipDirectory(originalDir, zipFile1);
        await new Promise(ok => setTimeout(ok, 2000)); // wait 2s
        await archive_1.zipDirectory(originalDir, zipFile2);
        const hash1 = archive_1.contentHash(await fs.readFile(zipFile1));
        const hash2 = archive_1.contentHash(await fs.readFile(zipFile2));
        test.deepEqual(hash1, hash2, 'md5 hash of two zips of the same content are not the same');
        test.done();
    },
    async 'zipDirectory follows symlinks'(test) {
        const originalDir = path.join(__dirname, 'test-archive-follow', 'data');
        const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
        const zipFile = path.join(stagingDir, 'output.zip');
        const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.follow'));
        try {
            await archive_1.zipDirectory(originalDir, zipFile);
            await exec(`unzip ${zipFile}`, { cwd: extractDir });
            await exec(`diff -bur ${originalDir} ${extractDir}`);
        }
        catch (e) {
            test.ok(false, `extracted directory ${extractDir} differs from original ${originalDir}, symlinks not followed.`);
        }
        await fs.remove(stagingDir);
        await fs.remove(extractDir);
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5hcmNoaXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVzdC5hcmNoaXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxpREFBOEM7QUFDOUMsK0JBQWdDO0FBQ2hDLCtCQUFnQztBQUVoQyx5QkFBMEI7QUFDMUIsNkJBQThCO0FBQzlCLCtCQUFpQztBQUNqQyw0Q0FBMkQ7QUFDM0QsTUFBTSxJQUFJLEdBQUcsZ0JBQVMsQ0FBQyxvQkFBSyxDQUFDLENBQUM7QUFFOUIsaUJBQVM7SUFDUCxLQUFLLENBQUMsNkRBQTZELENBQUMsSUFBVTtRQUM1RSxNQUFNLFVBQVUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUM1RSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNwRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUN6RCxNQUFNLFVBQVUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLE1BQU0sc0JBQVksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFekMsdURBQXVEO1FBQ3ZELE1BQU0sSUFBSSxDQUFDLFNBQVMsT0FBTyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUVwRCxJQUFJO1lBQ0YsTUFBTSxJQUFJLENBQUMsYUFBYSxXQUFXLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQztTQUN0RDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxL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JztcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQganN6aXAgPSByZXF1aXJlKCdqc3ppcCcpO1xuaW1wb3J0IHsgVGVzdCB9IGZyb20gJ25vZGV1bml0JztcbmltcG9ydCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgY29udGVudEhhc2gsIHppcERpcmVjdG9yeSB9IGZyb20gJy4uL2xpYi9hcmNoaXZlJztcbmNvbnN0IGV4ZWMgPSBwcm9taXNpZnkoX2V4ZWMpO1xuXG5leHBvcnQgPSB7XG4gIGFzeW5jICd6aXBEaXJlY3RvcnkgY2FuIHRha2UgYSBkaXJlY3RvcnkgYW5kIHByb2R1Y2UgYSB6aXAgZnJvbSBpdCcodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IHN0YWdpbmdEaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Rlc3QuYXJjaGl2ZScpKTtcbiAgICBjb25zdCB6aXBGaWxlID0gcGF0aC5qb2luKHN0YWdpbmdEaXIsICdvdXRwdXQuemlwJyk7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlJyk7XG4gICAgY29uc3QgZXh0cmFjdERpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdC5hcmNoaXZlLmV4dHJhY3QnKSk7XG4gICAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlKTtcblxuICAgIC8vIHVuemlwIGFuZCB2ZXJpZnkgdGhhdCB0aGUgcmVzdWx0aW5nIHRyZWUgaXMgdGhlIHNhbWVcbiAgICBhd2FpdCBleGVjKGB1bnppcCAke3ppcEZpbGV9YCwgeyBjd2Q6IGV4dHJhY3REaXIgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYyhgZGlmZiAtYnVyICR7b3JpZ2luYWxEaXJ9ICR7ZXh0cmFjdERpcn1gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0ZXN0Lm9rKGZhbHNlLCBgZXh0cmFjdGVkIGRpcmVjdG9yeSAke2V4dHJhY3REaXJ9IGRpZmZlcnMgZnJvbSBvcmlnaW5hbCAke29yaWdpbmFsRGlyfWApO1xuICAgIH1cblxuICAgIC8vIGluc3BlY3QgdGhlIHppbGUgZmlsZSB0byBjaGVjayB0aGF0IGRhdGVzIGFyZSByZXNldFxuICAgIGNvbnN0IHppcCA9IGF3YWl0IGZzLnJlYWRGaWxlKHppcEZpbGUpO1xuICAgIGNvbnN0IHppcERhdGEgPSBhd2FpdCBqc3ppcC5sb2FkQXN5bmMoemlwKTtcbiAgICBjb25zdCBkYXRlcyA9IE9iamVjdC52YWx1ZXMoemlwRGF0YS5maWxlcykubWFwKGZpbGUgPT4gZmlsZS5kYXRlLnRvSVNPU3RyaW5nKCkpO1xuICAgIHRlc3QuZXF1YWwoZGF0ZXNbMF0sICcxOTgwLTAxLTAxVDAwOjAwOjAwLjAwMFonLCAnRGF0ZXMgYXJlIG5vdCByZXNldCcpO1xuICAgIHRlc3QuZXF1YWwobmV3IFNldChkYXRlcykuc2l6ZSwgMSwgJ0RhdGVzIGFyZSBub3QgZXF1YWwnKTtcblxuICAgIC8vIGNoZWNrIHRoYXQgbW9kZSBpcyBwcmVzZXJ2ZWRcbiAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnMuc3RhdChwYXRoLmpvaW4oZXh0cmFjdERpciwgJ2V4ZWN1dGFibGUudHh0JykpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgY29uc3QgaXNFeGVjID0gKHN0YXQubW9kZSAmIGZzLmNvbnN0YW50cy5TX0lYVVNSKSB8fCAoc3RhdC5tb2RlICYgZnMuY29uc3RhbnRzLlNfSVhHUlApIHx8IChzdGF0Lm1vZGUgJiBmcy5jb25zdGFudHMuU19JWE9USCk7XG4gICAgdGVzdC5vayhpc0V4ZWMsICdGaWxlIGlzIG5vdCBleGVjdXRhYmxlJyk7XG5cbiAgICBhd2FpdCBmcy5yZW1vdmUoc3RhZ2luZ0Rpcik7XG4gICAgYXdhaXQgZnMucmVtb3ZlKGV4dHJhY3REaXIpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIGFzeW5jICdtZDUgaGFzaCBvZiBhIHppcCBzdGF5cyBjb25zaXN0ZW50IGFjcm9zcyBpbnZvY2F0aW9ucycodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IHN0YWdpbmdEaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Rlc3QuYXJjaGl2ZScpKTtcbiAgICBjb25zdCB6aXBGaWxlMSA9IHBhdGguam9pbihzdGFnaW5nRGlyLCAnb3V0cHV0LnppcCcpO1xuICAgIGNvbnN0IHppcEZpbGUyID0gcGF0aC5qb2luKHN0YWdpbmdEaXIsICdvdXRwdXQuemlwJyk7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlJyk7XG4gICAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlMSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2Uob2sgPT4gc2V0VGltZW91dChvaywgMjAwMCkpOyAvLyB3YWl0IDJzXG4gICAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlMik7XG5cbiAgICBjb25zdCBoYXNoMSA9IGNvbnRlbnRIYXNoKGF3YWl0IGZzLnJlYWRGaWxlKHppcEZpbGUxKSk7XG4gICAgY29uc3QgaGFzaDIgPSBjb250ZW50SGFzaChhd2FpdCBmcy5yZWFkRmlsZSh6aXBGaWxlMikpO1xuXG4gICAgdGVzdC5kZWVwRXF1YWwoaGFzaDEsIGhhc2gyLCAnbWQ1IGhhc2ggb2YgdHdvIHppcHMgb2YgdGhlIHNhbWUgY29udGVudCBhcmUgbm90IHRoZSBzYW1lJyk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgYXN5bmMgJ3ppcERpcmVjdG9yeSBmb2xsb3dzIHN5bWxpbmtzJyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlLWZvbGxvdycsICdkYXRhJyk7XG4gICAgY29uc3Qgc3RhZ2luZ0RpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdC5hcmNoaXZlJykpO1xuICAgIGNvbnN0IHppcEZpbGUgPSBwYXRoLmpvaW4oc3RhZ2luZ0RpciwgJ291dHB1dC56aXAnKTtcbiAgICBjb25zdCBleHRyYWN0RGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0LmFyY2hpdmUuZm9sbG93JykpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHppcERpcmVjdG9yeShvcmlnaW5hbERpciwgemlwRmlsZSk7XG4gICAgICBhd2FpdCBleGVjKGB1bnppcCAke3ppcEZpbGV9YCwgeyBjd2Q6IGV4dHJhY3REaXIgfSk7XG4gICAgICBhd2FpdCBleGVjKGBkaWZmIC1idXIgJHtvcmlnaW5hbERpcn0gJHtleHRyYWN0RGlyfWApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRlc3Qub2soZmFsc2UsIGBleHRyYWN0ZWQgZGlyZWN0b3J5ICR7ZXh0cmFjdERpcn0gZGlmZmVycyBmcm9tIG9yaWdpbmFsICR7b3JpZ2luYWxEaXJ9LCBzeW1saW5rcyBub3QgZm9sbG93ZWQuYCk7XG4gICAgfVxuXG4gICAgYXdhaXQgZnMucmVtb3ZlKHN0YWdpbmdEaXIpO1xuICAgIGF3YWl0IGZzLnJlbW92ZShleHRyYWN0RGlyKTtcbiAgICB0ZXN0LmRvbmUoKTtcbiAgfVxufTtcbiJdfQ==