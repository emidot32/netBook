"use strict";
const contextproviders = require("../../lib/context-providers");
const settings_1 = require("../../lib/settings");
const mockSDK = {
    defaultAccount: () => Promise.resolve('123456789012'),
    defaultRegion: () => Promise.resolve('bermuda-triangle-1337'),
    cloudFormation: () => { throw new Error('Not Mocked'); },
    ec2: () => { throw new Error('Not Mocked'); },
    ecr: () => { throw new Error('Not Mocked'); },
    route53: () => { throw new Error('Not Mocked'); },
    s3: () => { throw new Error('Not Mocked'); },
    ssm: () => { throw new Error('Not Mocked'); },
};
module.exports = {
    async 'errors are reported into the context value'(test) {
        // GIVEN
        contextproviders.registerContextProvider('testprovider', class {
            async getValue(_) {
                throw new Error('Something went wrong');
            }
        });
        const context = new settings_1.Context();
        // WHEN
        await contextproviders.provideContextValues([
            { key: 'asdf', props: {}, provider: 'testprovider' }
        ], context, mockSDK);
        // THEN - error is now in context
        // NOTE: error key is inlined here because it's part of the CX-API
        // compatibility surface.
        test.equals(context.get('asdf').$providerError, 'Something went wrong');
        test.done();
    },
    async 'errors are marked transient'(test) {
        // GIVEN
        contextproviders.registerContextProvider('testprovider', class {
            async getValue(_) {
                throw new Error('Something went wrong');
            }
        });
        const context = new settings_1.Context();
        // WHEN
        await contextproviders.provideContextValues([
            { key: 'asdf', props: {}, provider: 'testprovider' }
        ], context, mockSDK);
        // THEN - error is marked transient
        test.ok(context.get('asdf')[settings_1.TRANSIENT_CONTEXT_KEY]);
        test.done();
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5nZW5lcmljLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVzdC5nZW5lcmljLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFFQSxnRUFBaUU7QUFDakUsaURBQW9FO0FBRXBFLE1BQU0sT0FBTyxHQUFTO0lBQ3BCLGNBQWMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQztJQUNyRCxhQUFhLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQztJQUM3RCxjQUFjLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEQsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QyxPQUFPLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUM5QyxDQUFDO0FBRUYsaUJBQVM7SUFDUCxLQUFLLENBQUMsNENBQTRDLENBQUMsSUFBVTtRQUMzRCxRQUFRO1FBQ1IsZ0JBQWdCLENBQUMsdUJBQXVCLENBQUMsY0FBYyxFQUFFO1lBQ2hELEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBdUI7Z0JBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUMxQyxDQUFDO1NBQ0YsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxPQUFPLEdBQUcsSUFBSSxrQkFBTyxFQUFFLENBQUM7UUFFOUIsT0FBTztRQUNQLE1BQU0sZ0JBQWdCLENBQUMsb0JBQW9CLENBQUM7WUFDMUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRTtTQUNyRCxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVyQixpQ0FBaUM7UUFFakMsa0VBQWtFO1FBQ2xFLHlCQUF5QjtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLENBQUM7UUFFeEUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxJQUFVO1FBQzVDLFFBQVE7UUFDUixnQkFBZ0IsQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLEVBQUU7WUFDaEQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUF1QjtnQkFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQzFDLENBQUM7U0FDRixDQUFDLENBQUM7UUFDSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGtCQUFPLEVBQUUsQ0FBQztRQUU5QixPQUFPO1FBQ1AsTUFBTSxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQztZQUMxQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFO1NBQ3JELEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXJCLG1DQUFtQztRQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsZ0NBQXFCLENBQUMsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7Q0FDRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCB9IGZyb20gJ25vZGV1bml0JztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi8uLi9saWIvYXBpL3V0aWwvc2RrJztcbmltcG9ydCBjb250ZXh0cHJvdmlkZXJzID0gcmVxdWlyZSgnLi4vLi4vbGliL2NvbnRleHQtcHJvdmlkZXJzJyk7XG5pbXBvcnQgeyBDb250ZXh0LCBUUkFOU0lFTlRfQ09OVEVYVF9LRVkgfSBmcm9tICcuLi8uLi9saWIvc2V0dGluZ3MnO1xuXG5jb25zdCBtb2NrU0RLOiBJU0RLID0ge1xuICBkZWZhdWx0QWNjb3VudDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCcxMjM0NTY3ODkwMTInKSxcbiAgZGVmYXVsdFJlZ2lvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdiZXJtdWRhLXRyaWFuZ2xlLTEzMzcnKSxcbiAgY2xvdWRGb3JtYXRpb246ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgTW9ja2VkJyk7IH0sXG4gIGVjMjogKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBNb2NrZWQnKTsgfSxcbiAgZWNyOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignTm90IE1vY2tlZCcpOyB9LFxuICByb3V0ZTUzOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignTm90IE1vY2tlZCcpOyB9LFxuICBzMzogKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBNb2NrZWQnKTsgfSxcbiAgc3NtOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignTm90IE1vY2tlZCcpOyB9LFxufTtcblxuZXhwb3J0ID0ge1xuICBhc3luYyAnZXJyb3JzIGFyZSByZXBvcnRlZCBpbnRvIHRoZSBjb250ZXh0IHZhbHVlJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb250ZXh0cHJvdmlkZXJzLnJlZ2lzdGVyQ29udGV4dFByb3ZpZGVyKCd0ZXN0cHJvdmlkZXInLCBjbGFzcyB7XG4gICAgICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoXzoge1trZXk6IHN0cmluZ106IGFueX0pOiBQcm9taXNlPGFueT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG5cbiAgICAvLyBXSEVOXG4gICAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhbXG4gICAgICB7IGtleTogJ2FzZGYnLCBwcm9wczoge30sIHByb3ZpZGVyOiAndGVzdHByb3ZpZGVyJyB9XG4gICAgXSwgY29udGV4dCwgbW9ja1NESyk7XG5cbiAgICAvLyBUSEVOIC0gZXJyb3IgaXMgbm93IGluIGNvbnRleHRcblxuICAgIC8vIE5PVEU6IGVycm9yIGtleSBpcyBpbmxpbmVkIGhlcmUgYmVjYXVzZSBpdCdzIHBhcnQgb2YgdGhlIENYLUFQSVxuICAgIC8vIGNvbXBhdGliaWxpdHkgc3VyZmFjZS5cbiAgICB0ZXN0LmVxdWFscyhjb250ZXh0LmdldCgnYXNkZicpLiRwcm92aWRlckVycm9yLCAnU29tZXRoaW5nIHdlbnQgd3JvbmcnKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIGFzeW5jICdlcnJvcnMgYXJlIG1hcmtlZCB0cmFuc2llbnQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnRleHRwcm92aWRlcnMucmVnaXN0ZXJDb250ZXh0UHJvdmlkZXIoJ3Rlc3Rwcm92aWRlcicsIGNsYXNzIHtcbiAgICAgIHB1YmxpYyBhc3luYyBnZXRWYWx1ZShfOiB7W2tleTogc3RyaW5nXTogYW55fSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3JvbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcblxuICAgIC8vIFdIRU5cbiAgICBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKFtcbiAgICAgIHsga2V5OiAnYXNkZicsIHByb3BzOiB7fSwgcHJvdmlkZXI6ICd0ZXN0cHJvdmlkZXInIH1cbiAgICBdLCBjb250ZXh0LCBtb2NrU0RLKTtcblxuICAgIC8vIFRIRU4gLSBlcnJvciBpcyBtYXJrZWQgdHJhbnNpZW50XG4gICAgdGVzdC5vayhjb250ZXh0LmdldCgnYXNkZicpW1RSQU5TSUVOVF9DT05URVhUX0tFWV0pO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG59O1xuIl19