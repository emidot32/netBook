"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors/safe");
const version = require("../../lib/version");
const logging_1 = require("../logging");
const settings_1 = require("../settings");
const util_1 = require("../util");
exports.command = 'context';
exports.describe = 'Manage cached context values';
exports.builder = {
    reset: {
        alias: 'e',
        desc: 'The context key (or its index) to reset',
        type: 'string',
        requiresArg: true
    },
    clear: {
        desc: 'Clear all context',
        type: 'boolean',
    },
};
function handler(args) {
    args.commandHandler = realHandler;
}
exports.handler = handler;
async function realHandler(options) {
    const { configuration, args } = options;
    const contextValues = configuration.context.all;
    if (args.clear) {
        configuration.context.clear();
        await configuration.saveContext();
        logging_1.print('All context values cleared.');
    }
    else if (args.reset) {
        invalidateContext(configuration.context, args.reset);
        await configuration.saveContext();
    }
    else {
        // List -- support '--json' flag
        if (args.json) {
            process.stdout.write(JSON.stringify(contextValues, undefined, 2));
        }
        else {
            listContext(contextValues);
        }
    }
    await version.displayVersionMessage();
    return 0;
}
exports.realHandler = realHandler;
function listContext(context) {
    const keys = contextKeys(context);
    if (keys.length === 0) {
        logging_1.print(`This CDK application does not have any saved context values yet.`);
        logging_1.print('');
        logging_1.print(`Context will automatically be saved when you synthesize CDK apps`);
        logging_1.print(`that use environment context information like AZ information, VPCs,`);
        logging_1.print(`SSM parameters, and so on.`);
        return;
    }
    // Print config by default
    const data = [[colors.green('#'), colors.green('Key'), colors.green('Value')]];
    for (const [i, key] of keys) {
        const jsonWithoutNewlines = JSON.stringify(context[key], undefined, 2).replace(/\s+/g, ' ');
        data.push([i, key, jsonWithoutNewlines]);
    }
    logging_1.print(`Context found in ${colors.blue(settings_1.PROJECT_CONFIG)}:\n`);
    logging_1.print(util_1.renderTable(data, process.stdout.columns));
    // tslint:disable-next-line:max-line-length
    logging_1.print(`Run ${colors.blue('cdk context --reset KEY_OR_NUMBER')} to remove a context key. It will be refreshed on the next CDK synthesis run.`);
}
function invalidateContext(context, key) {
    const i = parseInt(key, 10);
    if (`${i}` === key) {
        // Twas a number and we fully parsed it.
        key = keyByNumber(context, i);
    }
    // Unset!
    if (context.has(key)) {
        context.unset(key);
        logging_1.print(`Context value ${colors.blue(key)} reset. It will be refreshed on next synthesis`);
    }
    else {
        logging_1.print(`No context value with key ${colors.blue(key)}`);
    }
}
function keyByNumber(context, n) {
    for (const [i, key] of contextKeys(context)) {
        if (n === i) {
            return key;
        }
    }
    throw new Error(`No context key with number: ${n}`);
}
/**
 * Return enumerated keys in a definitive order
 */
function contextKeys(context) {
    const keys = Object.keys(context);
    keys.sort();
    return enumerate1(keys);
}
function enumerate1(xs) {
    const ret = new Array();
    let i = 1;
    for (const x of xs) {
        ret.push([i, x]);
        i += 1;
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxzQ0FBdUM7QUFFdkMsNkNBQThDO0FBRTlDLHdDQUFtQztBQUNuQywwQ0FBc0Q7QUFDdEQsa0NBQXNDO0FBRXpCLFFBQUEsT0FBTyxHQUFHLFNBQVMsQ0FBQztBQUNwQixRQUFBLFFBQVEsR0FBRyw4QkFBOEIsQ0FBQztBQUMxQyxRQUFBLE9BQU8sR0FBRztJQUNyQixLQUFLLEVBQUU7UUFDTCxLQUFLLEVBQUUsR0FBRztRQUNWLElBQUksRUFBRSx5Q0FBeUM7UUFDL0MsSUFBSSxFQUFFLFFBQVE7UUFDZCxXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNELEtBQUssRUFBRTtRQUNMLElBQUksRUFBRSxtQkFBbUI7UUFDekIsSUFBSSxFQUFFLFNBQVM7S0FDaEI7Q0FDRixDQUFDO0FBRUYsU0FBZ0IsT0FBTyxDQUFDLElBQXFCO0lBQzNDLElBQUksQ0FBQyxjQUFjLEdBQUcsV0FBVyxDQUFDO0FBQ3BDLENBQUM7QUFGRCwwQkFFQztBQUVNLEtBQUssVUFBVSxXQUFXLENBQUMsT0FBdUI7SUFDdkQsTUFBTSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFFeEMsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7SUFFaEQsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ2QsYUFBYSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM5QixNQUFNLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNsQyxlQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztLQUN0QztTQUFNLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNyQixpQkFBaUIsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFlLENBQUMsQ0FBQztRQUMvRCxNQUFNLGFBQWEs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QVcsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUMzQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDWCxPQUFPLEdBQUcsQ0FBQztTQUNaO0tBQ0Y7SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsV0FBVyxDQUFDLE9BQVk7SUFDL0IsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDWixPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQixDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUksRUFBTztJQUM1QixNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBZSxDQUFDO0lBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2xCLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQixDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ1I7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY29sb3JzID0gcmVxdWlyZSgnY29sb3JzL3NhZmUnKTtcbmltcG9ydCB5YXJncyA9IHJlcXVpcmUoJ3lhcmdzJyk7XG5pbXBvcnQgdmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL2xpYi92ZXJzaW9uJyk7XG5pbXBvcnQgeyBDb21tYW5kT3B0aW9ucyB9IGZyb20gJy4uL2NvbW1hbmQtYXBpJztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb250ZXh0LCBQUk9KRUNUX0NPTkZJRyB9IGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCB7IHJlbmRlclRhYmxlIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBjb21tYW5kID0gJ2NvbnRleHQnO1xuZXhwb3J0IGNvbnN0IGRlc2NyaWJlID0gJ01hbmFnZSBjYWNoZWQgY29udGV4dCB2YWx1ZXMnO1xuZXhwb3J0IGNvbnN0IGJ1aWxkZXIgPSB7XG4gIHJlc2V0OiB7XG4gICAgYWxpYXM6ICdlJyxcbiAgICBkZXNjOiAnVGhlIGNvbnRleHQga2V5IChvciBpdHMgaW5kZXgpIHRvIHJlc2V0JyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICByZXF1aXJlc0FyZzogdHJ1ZVxuICB9LFxuICBjbGVhcjoge1xuICAgIGRlc2M6ICdDbGVhciBhbGwgY29udGV4dCcsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZXIoYXJnczogeWFyZ3MuQXJndW1lbnRzKSB7XG4gIGFyZ3MuY29tbWFuZEhhbmRsZXIgPSByZWFsSGFuZGxlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWxIYW5kbGVyKG9wdGlvbnM6IENvbW1hbmRPcHRpb25zKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3QgeyBjb25maWd1cmF0aW9uLCBhcmdzIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZXMgPSBjb25maWd1cmF0aW9uLmNvbnRleHQuYWxsO1xuXG4gIGlmIChhcmdzLmNsZWFyKSB7XG4gICAgY29uZmlndXJhdGlvbi5jb250ZXh0LmNsZWFyKCk7XG4gICAgYXdhaXQgY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuICAgIHByaW50KCdBbGwgY29udGV4dCB2YWx1ZXMgY2xlYXJlZC4nKTtcbiAgfSBlbHNlIGlmIChhcmdzLnJlc2V0KSB7XG4gICAgaW52YWxpZGF0ZUNvbnRleHQoY29uZmlndXJhdGlvbi5jb250ZXh0LCBhcmdzLnJlc2V0IGFzIHN0cmluZyk7XG4gICAgYXdhaXQgY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIExpc3QgLS0gc3VwcG9ydCAnLS1qc29uJyBmbGFnXG4gICAgaWYgKGFyZ3MuanNvbikge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkoY29udGV4dFZhbHVlcywgdW5kZWZpbmVkLCAyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RDb250ZXh0KGNvbnRleHRWYWx1ZXMpO1xuICAgIH1cbiAgfVxuICBhd2FpdCB2ZXJzaW9uLmRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBsaXN0Q29udGV4dChjb250ZXh0OiBhbnkpIHtcbiAgY29uc3Qga2V5cyA9IGNvbnRleHRLZXlzKGNvbnRleHQpO1xuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHByaW50KGBUaGlzIENESyBhcHBsaWNhdGlvbiBkb2VzIG5vdCBoYXZlIGFueSBzYXZlZCBjb250ZXh0IHZhbHVlcyB5ZXQuYCk7XG4gICAgcHJpbnQoJycpO1xuICAgIHByaW50KGBDb250ZXh0IHdpbGwgYXV0b21hdGljYWxseSBiZSBzYXZlZCB3aGVuIHlvdSBzeW50aGVzaXplIENESyBhcHBzYCk7XG4gICAgcHJpbnQoYHRoYXQgdXNlIGVudmlyb25tZW50IGNvbnRleHQgaW5mb3JtYXRpb24gbGlrZSBBWiBpbmZvcm1hdGlvbiwgVlBDcyxgKTtcbiAgICBwcmludChgU1NNIHBhcmFtZXRlcnMsIGFuZCBzbyBvbi5gKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFByaW50IGNvbmZpZyBieSBkZWZhdWx0XG4gIGNvbnN0IGRhdGE6IGFueVtdID0gW1tjb2xvcnMuZ3JlZW4oJyMnKSwgY29sb3JzLmdyZWVuKCdLZXknKSwgY29sb3JzLmdyZWVuKCdWYWx1ZScpXV07XG4gIGZvciAoY29uc3QgW2ksIGtleV0gb2Yga2V5cykge1xuICAgIGNvbnN0IGpzb25XaXRob3V0TmV3bGluZXMgPSBKU09OLnN0cmluZ2lmeShjb250ZXh0W2tleV0sIHVuZGVmaW5lZCwgMikucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIGRhdGEucHVzaChbaSwga2V5LCBqc29uV2l0aG91dE5ld2xpbmVzXSk7XG4gIH1cblxuICBwcmludChgQ29udGV4dCBmb3VuZCBpbiAke2NvbG9ycy5ibHVlKFBST0pFQ1RfQ09ORklHKX06XFxuYCk7XG5cbiAgcHJpbnQocmVuZGVyVGFibGUoZGF0YSwgcHJvY2Vzcy5zdGRvdXQuY29sdW1ucykpO1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgcHJpbnQoYFJ1biAke2NvbG9ycy5ibHVlKCdjZGsgY29udGV4dCAtLXJlc2V0IEtFWV9PUl9OVU1CRVInKX0gdG8gcmVtb3ZlIGEgY29udGV4dCBrZXkuIEl0IHdpbGwgYmUgcmVmcmVzaGVkIG9uIHRoZSBuZXh0IENESyBzeW50aGVzaXMgcnVuLmApO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dChjb250ZXh0OiBDb250ZXh0LCBrZXk6IHN0cmluZykge1xuICBjb25zdCBpID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChgJHtpfWAgPT09IGtleSkge1xuICAgIC8vIFR3YXMgYSBudW1iZXIgYW5kIHdlIGZ1bGx5IHBhcnNlZCBpdC5cbiAgICBrZXkgPSBrZXlCeU51bWJlcihjb250ZXh0LCBpKTtcbiAgfVxuXG4gIC8vIFVuc2V0IVxuICBpZiAoY29udGV4dC5oYXMoa2V5KSkge1xuICAgIGNvbnRleHQudW5zZXQoa2V5KTtcbiAgICBwcmludChgQ29udGV4dCB2YWx1ZSAke2NvbG9ycy5ibHVlKGtleSl9IHJlc2V0LiBJdCB3aWxsIGJlIHJlZnJlc2hlZCBvbiBuZXh0IHN5bnRoZXNpc2ApO1xuICB9IGVsc2Uge1xuICAgIHByaW50KGBObyBjb250ZXh0IHZhbHVlIHdpdGgga2V5ICR7Y29sb3JzLmJsdWUoa2V5KX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXlCeU51bWJlcihjb250ZXh0OiBhbnksIG46IG51bWJlcikge1xuICBmb3IgKGNvbnN0IFtpLCBrZXldIG9mIGNvbnRleHRLZXlzKGNvbnRleHQpKSB7XG4gICAgaWYgKG4gPT09IGkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgTm8gY29udGV4dCBrZXkgd2l0aCBudW1iZXI6ICR7bn1gKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZW51bWVyYXRlZCBrZXlzIGluIGEgZGVmaW5pdGl2ZSBvcmRlclxuICovXG5mdW5jdGlvbiBjb250ZXh0S2V5cyhjb250ZXh0OiBhbnkpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNvbnRleHQpO1xuICBrZXlzLnNvcnQoKTtcbiAgcmV0dXJuIGVudW1lcmF0ZTEoa2V5cyk7XG59XG5cbmZ1bmN0aW9uIGVudW1lcmF0ZTE8VD4oeHM6IFRbXSk6IEFycmF5PFtudW1iZXIsIFRdPiB7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxbbnVtYmVyLCBUXT4oKTtcbiAgbGV0IGkgPSAxO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICByZXQucHVzaChbaSwgeF0pO1xuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19