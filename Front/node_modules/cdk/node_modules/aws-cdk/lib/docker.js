"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logging_1 = require("./logging");
const os_1 = require("./os");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 *
 * When running in CI, we pull the latest image first and use it as cache for
 * the build. Generally pulling will be faster than building, especially for
 * Dockerfiles with lots of OS/code packages installation or changes only in
 * the bottom layers. When running locally chances are that we already have
 * layers cache available.
 *
 * CI is detected by the presence of the `CI` environment variable or
 * the `--ci` command line option.
 */
async function prepareContainerAsset(assemblyDir, asset, toolkitInfo, reuse, ci) {
    if (reuse) {
        return [
            { ParameterKey: asset.imageNameParameter, UsePreviousValue: true },
        ];
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    try {
        const ecr = await toolkitInfo.prepareEcrRepository(asset);
        const latest = `${ecr.repositoryUri}:latest`;
        let loggedIn = false;
        // In CI we try to pull latest first
        if (ci) {
            await dockerLogin(toolkitInfo);
            loggedIn = true;
            try {
                await os_1.shell(['docker', 'pull', latest]);
            }
            catch (e) {
                logging_1.debug('Failed to pull latest image from ECR repository');
            }
        }
        const buildArgs = [].concat(...Object.entries(asset.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`]));
        const baseCommand = [
            'docker', 'build',
            ...buildArgs,
            '--tag', latest,
            contextPath
        ];
        if (asset.target) {
            baseCommand.push('--target', asset.target);
        }
        const command = ci
            ? [...baseCommand, '--cache-from', latest] // This does not fail if latest is not available
            : baseCommand;
        await os_1.shell(command);
        // Login and push
        if (!loggedIn) { // We could be already logged in if in CI
            await dockerLogin(toolkitInfo);
            loggedIn = true;
        }
        // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
        logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
        await os_1.shell(['docker', 'push', latest]);
        logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
        // Get the (single) repo-digest for latest, which'll be <ecr.repositoryUrl>@sha256:<repoImageSha256>
        const repoDigests = (await os_1.shell(['docker', 'image', 'inspect', latest, '--format', '{{range .RepoDigests}}{{.}}|{{end}}'])).trim();
        const requiredPrefix = `${ecr.repositoryUri}@sha256:`;
        const repoDigest = repoDigests.split('|').find(digest => digest.startsWith(requiredPrefix));
        if (!repoDigest) {
            throw new Error(`Unable to identify repository digest (none starts with ${requiredPrefix}) in:\n${repoDigests}`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: repoDigest.replace(ecr.repositoryUri, ecr.repositoryName) },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Get credentials from ECR and run docker login
 */
async function dockerLogin(toolkitInfo) {
    const credentials = await toolkitInfo.getEcrCredentials();
    await os_1.shell(['docker', 'login',
        '--username', credentials.username,
        '--password', credentials.password,
        credentials.endpoint]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsNkJBQThCO0FBRTlCLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxXQUFtQixFQUNuQixLQUF1QyxFQUN2QyxXQUF3QixFQUN4QixLQUFjLEVBQ2QsRUFBWTtJQUV0RCxJQUFJLEtBQUssRUFBRTtRQUNULE9BQU87WUFDTCxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1NBQ25FLENBQUM7S0FDSDtJQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFbEcsZUFBSyxDQUFDLG9DQUFvQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRXpELElBQUk7UUFDRixNQUFNLEdBQUcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxRCxNQUFNLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxhQUFhLFNBQVMsQ0FBQztRQUU3QyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFFckIsb0NBQW9DO1FBQ3BDLElBQUksRUFBRSxFQUFFO1lBQ04sTUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDL0IsUUFBUSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJO2dCQUNGLE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQ3pDO1lBQUMsT0FB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QUMsUUFBUTtRQUNsQyxZQUFZLEVBQUUsV0FBVyxDQUFDLFFBQVE7UUFDbEMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uIH0gZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi9hcGkvdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IGRlYnVnLCBwcmludCB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4vb3MnO1xuXG4vKipcbiAqIEJ1aWxkIGFuZCB1cGxvYWQgYSBEb2NrZXIgaW1hZ2VcbiAqXG4gKiBQZXJtYW5lbnRseSBpZGVudGlmeWluZyBpbWFnZXMgaXMgYSBiaXQgb2YgYSBidXN0LiBOZXdlciBEb2NrZXIgdmVyc2lvbiB1c2VcbiAqIGEgZGlnZXN0IChzaGEyNTY6eHh4eCkgYXMgYW4gaW1hZ2UgaWRlbnRpZmllciwgd2hpY2ggaXMgcHJldHR5IGdvb2QgdG8gYXZvaWRcbiAqIHNwdXJpb3VzIHJlYnVpbGRzLiBIb3dldmVyLCB0aGlzIGRpZ2VzdCBpcyBjYWxjdWxhdGVkIG92ZXIgYSBtYW5pZmVzdCB0aGF0XG4gKiBpbmNsdWRlcyBtZXRhZGF0YSB0aGF0IGlzIGxpYWJsZSB0byBjaGFuZ2UuIEZvciBleGFtcGxlLCBhcyBzb29uIGFzIHdlXG4gKiBwdXNoIHRoZSBEb2NrZXIgaW1hZ2UgdG8gYSByZXBvc2l0b3J5LCB0aGUgZGlnZXN0IGNoYW5nZXMuIFRoaXMgbWFrZXMgdGhlXG4gKiBkaWdlc3Qgd29ydGhsZXNzIHRvIGRldGVybWUgd2hldGhlciB3ZSBhbHJlYWR5IHB1c2hlZCBhbiBpbWFnZSwgZm9yIGV4YW1wbGUuXG4gKlxuICogQXMgYSB3b3JrYXJvdW5kLCB3ZSBjYWxjdWxhdGUgb3VyIG93biBkaWdlc3Qgb3ZlciBwYXJ0cyBvZiB0aGUgbWFuaWZlc3QgdGhhdFxuICogYXJlIHVubGlrZWx5IHRvIGNoYW5nZSwgYW5kIHRhZyBiYXNlZCBvbiB0aGF0LlxuICpcbiAqIFdoZW4gcnVubmluZyBpbiBDSSwgd2UgcHVsbCB0aGUgbGF0ZXN0IGltYWdlIGZpcnN0IGFuZCB1c2UgaXQgYXMgY2FjaGUgZm9yXG4gKiB0aGUgYnVpbGQuIEdlbmVyYWxseSBwdWxsaW5nIHdpbGwgYmUgZmFzdGVyIHRoYW4gYnVpbGRpbmcsIGVzcGVjaWFsbHkgZm9yXG4gKiBEb2NrZXJmaWxlcyB3aXRoIGxvdHMgb2YgT1MvY29kZSBwYWNrYWdlcyBpbnN0YWxsYXRpb24gb3IgY2hhbmdlcyBvbmx5IGluXG4gKiB0aGUgYm90dG9tIGxheWVycy4gV2hlbiBydW5uaW5nIGxvY2FsbHkgY2hhbmNlcyBhcmUgdGhhdCB3ZSBhbHJlYWR5IGhhdmVcbiAqIGxheWVycyBjYWNoZSBhdmFpbGFibGUuXG4gKlxuICogQ0kgaXMgZGV0ZWN0ZWQgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBgQ0lgIGVudmlyb25tZW50IHZhcmlhYmxlIG9yXG4gKiB0aGUgYC0tY2lgIGNvbW1hbmQgbGluZSBvcHRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udGFpbmVyQXNzZXQoYXNzZW1ibHlEaXI6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXQ6IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldXNlOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaT86IGJvb2xlYW4pOiBQcm9taXNlPFtDbG91ZEZvcm1hdGlvbi5QYXJhbWV0ZXJdPiB7XG5cbiAgaWYgKHJldXNlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgUGFyYW1ldGVyS2V5OiBhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIsIFVzZVByZXZpb3VzVmFsdWU6IHRydWUgfSxcbiAgICBdO1xuICB9XG5cbiAgY29uc3QgY29udGV4dFBhdGggPSBwYXRoLmlzQWJzb2x1dGUoYXNzZXQucGF0aCkgPyBhc3NldC5wYXRoIDogcGF0aC5qb2luKGFzc2VtYmx5RGlyLCBhc3NldC5wYXRoKTtcblxuICBkZWJ1ZygnIPCfkZEgIFByZXBhcmluZyBEb2NrZXIgaW1hZ2UgYXNzZXQ6JywgY29udGV4dFBhdGgpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdG9vbGtpdEluZm8ucHJlcGFyZUVjclJlcG9zaXRvcnkoYXNzZXQpO1xuICAgIGNvbnN0IGxhdGVzdCA9IGAke2Vjci5yZXBvc2l0b3J5VXJpfTpsYXRlc3RgO1xuXG4gICAgbGV0IGxvZ2dlZEluID0gZmFsc2U7XG5cbiAgICAvLyBJbiBDSSB3ZSB0cnkgdG8gcHVsbCBsYXRlc3QgZmlyc3RcbiAgICBpZiAoY2kpIHtcbiAgICAgIGF3YWl0IGRvY2tlckxvZ2luKHRvb2xraXRJbmZvKTtcbiAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc2hlbGwoWydkb2NrZXInLCAncHVsbCcsIGxhdGVzdF0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnRmFpbGVkIHRvIHB1bGwgbGF0ZXN0IGltYWdlIGZyb20gRUNSIHJlcG9zaXRvcnknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBidWlsZEFyZ3MgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdCguLi5PYmplY3QuZW50cmllcyhhc3NldC5idWlsZEFyZ3MgfHwge30pLm1hcCgoW2ssIHZdKSA9PiBbJy0tYnVpbGQtYXJnJywgYCR7a309JHt2fWBdKSk7XG5cbiAgICBjb25zdCBiYXNlQ29tbWFuZCA9IFtcbiAgICAgICdkb2NrZXInLCAnYnVpbGQnLFxuICAgICAgLi4uYnVpbGRBcmdzLFxuICAgICAgJy0tdGFnJywgbGF0ZXN0LFxuICAgICAgY29udGV4dFBhdGhcbiAgICBdO1xuXG4gICAgaWYgKGFzc2V0LnRhcmdldCkge1xuICAgICAgYmFzZUNvbW1hbmQucHVzaCgnLS10YXJnZXQnLCBhc3NldC50YXJnZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBjaVxuICAgICAgPyBbLi4uYmFzZUNvbW1hbmQsICctLWNhY2hlLWZyb20nLCBsYXRlc3RdIC8vIFRoaXMgZG9lcyBub3QgZmFpbCBpZiBsYXRlc3QgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgOiBiYXNlQ29tbWFuZDtcbiAgICBhd2FpdCBzaGVsbChjb21tYW5kKTtcblxuICAgIC8vIExvZ2luIGFuZCBwdXNoXG4gICAgaWYgKCFsb2dnZWRJbikgeyAvLyBXZSBjb3VsZCBiZSBhbHJlYWR5IGxvZ2dlZCBpbiBpZiBpbiBDSVxuICAgICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgdGhpcyBxdWlldCwgc28gd2UgY2FuJ3QgdXNlIGEgUGxlYXNlSG9sZC4gUHJpbnQgYSBoZWFkZXIgbWVzc2FnZS5cbiAgICBwcmludChgIOKMmyBQdXNoaW5nIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH07IHRoaXMgbWF5IHRha2UgYSB3aGlsZS5gKTtcbiAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdXNoJywgbGF0ZXN0XSk7XG4gICAgZGVidWcoYCDwn5GRICBEb2NrZXIgaW1hZ2UgZm9yICR7Y29udGV4dFBhdGh9IHB1c2hlZC5gKTtcblxuICAgIC8vIEdldCB0aGUgKHNpbmdsZSkgcmVwby1kaWdlc3QgZm9yIGxhdGVzdCwgd2hpY2gnbGwgYmUgPGVjci5yZXBvc2l0b3J5VXJsPkBzaGEyNTY6PHJlcG9JbWFnZVNoYTI1Nj5cbiAgICBjb25zdCByZXBvRGlnZXN0cyA9IChhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdpbWFnZScsICdpbnNwZWN0JywgbGF0ZXN0LCAnLS1mb3JtYXQnLCAne3tyYW5nZSAuUmVwb0RpZ2VzdHN9fXt7Ln19fHt7ZW5kfX0nXSkpLnRyaW0oKTtcbiAgICBjb25zdCByZXF1aXJlZFByZWZpeCA9IGAke2Vjci5yZXBvc2l0b3J5VXJpfUBzaGEyNTY6YDtcbiAgICBjb25zdCByZXBvRGlnZXN0ID0gcmVwb0RpZ2VzdHMuc3BsaXQoJ3wnKS5maW5kKGRpZ2VzdCA9PiBkaWdlc3Quc3RhcnRzV2l0aChyZXF1aXJlZFByZWZpeCkpO1xuICAgIGlmICghcmVwb0RpZ2VzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaWRlbnRpZnkgcmVwb3NpdG9yeSBkaWdlc3QgKG5vbmUgc3RhcnRzIHdpdGggJHtyZXF1aXJlZFByZWZpeH0pIGluOlxcbiR7cmVwb0RpZ2VzdHN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHsgUGFyYW1ldGVyS2V5OiBhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIsIFBhcmFtZXRlclZhbHVlOiByZXBvRGlnZXN0LnJlcGxhY2UoZWNyLnJlcG9zaXRvcnlVcmksIGVjci5yZXBvc2l0b3J5TmFtZSkgfSxcbiAgICBdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYnVpbGRpbmcgRG9ja2VyIGltYWdlIGFzc2V0OyB5b3UgbmVlZCB0byBoYXZlIERvY2tlciBpbnN0YWxsZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBidWlsZCBpbWFnZSBhc3NldHMuIFBsZWFzZSBpbnN0YWxsIERvY2tlciBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNyZWRlbnRpYWxzIGZyb20gRUNSIGFuZCBydW4gZG9ja2VyIGxvZ2luXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvY2tlckxvZ2luKHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbykge1xuICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IHRvb2xraXRJbmZvLmdldEVjckNyZWRlbnRpYWxzKCk7XG4gIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2xvZ2luJyxcbiAgJy0tdXNlcm5hbWUnLCBjcmVkZW50aWFscy51c2VybmFtZSxcbiAgJy0tcGFzc3dvcmQnLCBjcmVkZW50aWFscy5wYXNzd29yZCxcbiAgY3JlZGVudGlhbHMuZW5kcG9pbnRdKTtcbn1cbiJdfQ==