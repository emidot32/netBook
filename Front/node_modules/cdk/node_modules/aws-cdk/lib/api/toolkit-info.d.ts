/// <reference types="node" />
import cxapi = require('@aws-cdk/cx-api');
import { ISDK } from './util/sdk';
/** @experimental */
export interface UploadProps {
    s3KeyPrefix?: string;
    s3KeySuffix?: string;
    contentType?: string;
}
/** @experimental */
export interface Uploaded {
    filename: string;
    key: string;
    hash: string;
    changed: boolean;
}
/** @experimental */
export declare class ToolkitInfo {
    private readonly props;
    readonly sdk: ISDK;
    /**
     * A cache of previous uploads done in this session
     */
    private readonly previousUploads;
    constructor(props: {
        sdk: ISDK;
        bucketName: string;
        bucketEndpoint: string;
        environment: cxapi.Environment;
    });
    readonly bucketUrl: string;
    readonly bucketName: string;
    /**
     * Uploads a data blob to S3 under the specified key prefix.
     * Uses a hash to render the full key and skips upload if an object
     * already exists by this key.
     */
    uploadIfChanged(data: string | Buffer | DataView, props: UploadProps): Promise<Uploaded>;
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     * @experimental
     */
    prepareEcrRepository(asset: cxapi.ContainerImageAssetMetadataEntry): Promise<EcrRepositoryInfo>;
    /**
     * Get ECR credentials
     */
    getEcrCredentials(): Promise<EcrCredentials>;
    /**
     * Check if image already exists in ECR repository
     */
    checkEcrImage(repositoryName: string, imageTag: string): Promise<boolean>;
}
/** @experimental */
export interface EcrRepositoryInfo {
    repositoryUri: string;
    repositoryName: string;
}
/** @experimental */
export interface EcrCredentials {
    username: string;
    password: string;
    endpoint: string;
}
/** @experimental */
export declare function loadToolkitInfo(environment: cxapi.Environment, sdk: ISDK, stackName: string): Promise<ToolkitInfo | undefined>;
export declare const DEFAULT_REPO_LIFECYCLE: {
    rules: {
        rulePriority: number;
        description: string;
        selection: {
            tagStatus: string;
            countType: string;
            countNumber: number;
        };
        action: {
            type: string;
        };
    }[];
};
