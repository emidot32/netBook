"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors/safe");
const archive_1 = require("../archive");
const logging_1 = require("../logging");
const credentials_1 = require("./aws-auth/credentials");
const bootstrap_environment_1 = require("./bootstrap-environment");
const cloudformation_1 = require("./util/cloudformation");
/** @experimental */
class ToolkitInfo {
    constructor(props) {
        this.props = props;
        /**
         * A cache of previous uploads done in this session
         */
        this.previousUploads = {};
        this.sdk = props.sdk;
    }
    get bucketUrl() {
        return `https://${this.props.bucketEndpoint}`;
    }
    get bucketName() {
        return this.props.bucketName;
    }
    /**
     * Uploads a data blob to S3 under the specified key prefix.
     * Uses a hash to render the full key and skips upload if an object
     * already exists by this key.
     */
    async uploadIfChanged(data, props) {
        const s3 = await this.props.sdk.s3(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForWriting);
        const s3KeyPrefix = props.s3KeyPrefix || '';
        const s3KeySuffix = props.s3KeySuffix || '';
        const bucket = this.props.bucketName;
        const hash = archive_1.contentHash(data);
        const filename = `${hash}${s3KeySuffix}`;
        const key = `${s3KeyPrefix}${filename}`;
        const url = `s3://${bucket}/${key}`;
        logging_1.debug(`${url}: checking if already exists`);
        if (await objectExists(s3, bucket, key)) {
            logging_1.debug(`${url}: found (skipping upload)`);
            return { filename, key, hash, changed: false };
        }
        const uploaded = { filename, key, hash, changed: true };
        // Upload if it's new or server-side copy if it was already uploaded previously
        const previous = this.previousUploads[hash];
        if (previous) {
            logging_1.debug(`${url}: copying`);
            await s3.copyObject({
                Bucket: bucket,
                Key: key,
                CopySource: `${bucket}/${previous.key}`
            }).promise();
            logging_1.debug(`${url}: copy complete`);
        }
        else {
            logging_1.debug(`${url}: uploading`);
            await s3.putObject({
                Bucket: bucket,
                Key: key,
                Body: data,
                ContentType: props.contentType
            }).promise();
            logging_1.debug(`${url}: upload complete`);
            this.previousUploads[hash] = uploaded;
        }
        return uploaded;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     * @experimental
     */
    async prepareEcrRepository(asset) {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForWriting);
        let repositoryName;
        if (asset.repositoryName) {
            // Repository name provided by user
            repositoryName = asset.repositoryName;
        }
        else {
            // Repository name based on asset id
            const assetId = asset.id;
            repositoryName = 'cdk/' + assetId.replace(/[:/]/g, '-').toLowerCase();
        }
        let repository;
        try {
            logging_1.debug(`${repositoryName}: checking for repository.`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            repository = describeResponse.repositories[0];
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        if (repository) {
            return {
                repositoryUri: repository.repositoryUri,
                repositoryName
            };
        }
        logging_1.debug(`${repositoryName}: creating`);
        const response = await ecr.createRepository({ repositoryName }).promise();
        repository = response.repository;
        // Better put a lifecycle policy on this so as to not cost too much money
        await ecr.putLifecyclePolicy({
            repositoryName,
            lifecyclePolicyText: JSON.stringify(exports.DEFAULT_REPO_LIFECYCLE)
        }).promise();
        // Configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        await ecr.putImageScanningConfiguration({
            repositoryName,
            imageScanningConfiguration: {
                scanOnPush: true
            }
        }).promise();
        return {
            repositoryUri: repository.repositoryUri,
            repositoryName
        };
    }
    /**
     * Get ECR credentials
     */
    async getEcrCredentials() {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForReading);
        logging_1.debug(`Fetching ECR authorization token`);
        const authData = (await ecr.getAuthorizationToken({}).promise()).authorizationData || [];
        if (authData.length === 0) {
            throw new Error('No authorization data received from ECR');
        }
        const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
        const [username, password] = token.split(':');
        return {
            username,
            password,
            endpoint: authData[0].proxyEndpoint,
        };
    }
    /**
     * Check if image already exists in ECR repository
     */
    async checkEcrImage(repositoryName, imageTag) {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForReading);
        try {
            logging_1.debug(`${repositoryName}: checking for image ${imageTag}`);
            await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
            // If we got here, the image already exists. Nothing else needs to be done.
            return true;
        }
        catch (e) {
            if (e.code !== 'ImageNotFoundException') {
                throw e;
            }
        }
        return false;
    }
}
exports.ToolkitInfo = ToolkitInfo;
async function objectExists(s3, bucket, key) {
    try {
        await s3.headObject({ Bucket: bucket, Key: key }).promise();
        return true;
    }
    catch (e) {
        if (e.code === 'NotFound') {
            return false;
        }
        throw e;
    }
}
/** @experimental */
async function loadToolkitInfo(environment, sdk, stackName) {
    const cfn = await sdk.cloudFormation(environment.account, environment.region, credentials_1.Mode.ForReading);
    const stack = await cloudformation_1.waitForStack(cfn, stackName);
    if (!stack) {
        logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
        return undefined;
    }
    return new ToolkitInfo({
        sdk, environment,
        bucketName: getOutputValue(stack, bootstrap_environment_1.BUCKET_NAME_OUTPUT),
        bucketEndpoint: getOutputValue(stack, bootstrap_environment_1.BUCKET_DOMAIN_NAME_OUTPUT)
    });
}
exports.loadToolkitInfo = loadToolkitInfo;
function getOutputValue(stack, output) {
    let result;
    if (stack.Outputs) {
        const found = stack.Outputs.find(o => o.OutputKey === output);
        result = found && found.OutputValue;
    }
    if (result === undefined) {
        throw new Error(`The CDK toolkit stack (${stack.StackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
    }
    return result;
}
exports.DEFAULT_REPO_LIFECYCLE = {
    rules: [
        {
            rulePriority: 100,
            description: 'Retain only 5 images',
            selection: {
                tagStatus: 'any',
                countType: 'imageCountMoreThan',
                countNumber: 5,
            },
            action: { type: 'expire' }
        }
    ]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsc0NBQXVDO0FBQ3ZDLHdDQUF5QztBQUN6Qyx3Q0FBbUM7QUFDbkMsd0RBQThDO0FBQzlDLG1FQUF5RjtBQUN6RiwwREFBcUQ7QUFrQnJELG9CQUFvQjtBQUNwQixNQUFhLFdBQVc7SUFRdEIsWUFBNkIsS0FLNUI7UUFMNEIsVUFBSyxHQUFMLEtBQUssQ0FLakM7UUFWRDs7V0FFRztRQUNjLG9CQUFlLEdBQThCLEVBQUUsQ0FBQztRQVEvRCxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQVcsU0FBUztRQUNsQixPQUFPLFdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBRUQsSUFBVyxVQUFVO1FBQ25CLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUFDLElBQWdDLEVBQUUsS0FBa0I7UUFDL0UsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxrQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRW5ILE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO1FBQzVDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO1FBRTVDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDO1FBRXJDLE1BQU0sSUFBSSxHQUFH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OlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgYXdzID0gcmVxdWlyZSgnYXdzLXNkaycpO1xuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgeyBjb250ZW50SGFzaCB9IGZyb20gJy4uL2FyY2hpdmUnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQsIEJVQ0tFVF9OQU1FX09VVFBVVCAgfSBmcm9tICcuL2Jvb3RzdHJhcC1lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyB3YWl0Rm9yU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4vdXRpbC9zZGsnO1xuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRQcm9wcyB7XG4gIHMzS2V5UHJlZml4Pzogc3RyaW5nLFxuICBzM0tleVN1ZmZpeD86IHN0cmluZyxcbiAgY29udGVudFR5cGU/OiBzdHJpbmcsXG59XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZGVkIHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAga2V5OiBzdHJpbmc7XG4gIGhhc2g6IHN0cmluZztcbiAgY2hhbmdlZDogYm9vbGVhbjtcbn1cblxuLyoqIEBleHBlcmltZW50YWwgKi9cbmV4cG9ydCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBzZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgcHJldmlvdXMgdXBsb2FkcyBkb25lIGluIHRoaXMgc2Vzc2lvblxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBwcmV2aW91c1VwbG9hZHM6IHtba2V5OiBzdHJpbmddOiBVcGxvYWRlZH0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiB7XG4gICAgc2RrOiBJU0RLLFxuICAgIGJ1Y2tldE5hbWU6IHN0cmluZyxcbiAgICBidWNrZXRFbmRwb2ludDogc3RyaW5nLFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudFxuICB9KSB7XG4gICAgdGhpcy5zZGsgPSBwcm9wcy5zZGs7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnByb3BzLmJ1Y2tldEVuZHBvaW50fWA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuYnVja2V0TmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZGF0YSBibG9iIHRvIFMzIHVuZGVyIHRoZSBzcGVjaWZpZWQga2V5IHByZWZpeC5cbiAgICogVXNlcyBhIGhhc2ggdG8gcmVuZGVyIHRoZSBmdWxsIGtleSBhbmQgc2tpcHMgdXBsb2FkIGlmIGFuIG9iamVjdFxuICAgKiBhbHJlYWR5IGV4aXN0cyBieSB0aGlzIGtleS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGxvYWRJZkNoYW5nZWQoZGF0YTogc3RyaW5nIHwgQnVmZmVyIHwgRGF0YVZpZXcsIHByb3BzOiBVcGxvYWRQcm9wcyk6IFByb21pc2U8VXBsb2FkZWQ+IHtcbiAgICBjb25zdCBzMyA9IGF3YWl0IHRoaXMucHJvcHMuc2RrLnMzKHRoaXMucHJvcHMuZW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5wcm9wcy5lbnZpcm9ubWVudC5yZWdpb24sIE1vZGUuRm9yV3JpdGluZyk7XG5cbiAgICBjb25zdCBzM0tleVByZWZpeCA9IHByb3BzLnMzS2V5UHJlZml4IHx8ICcnO1xuICAgIGNvbnN0IHMzS2V5U3VmZml4ID0gcHJvcHMuczNLZXlTdWZmaXggfHwgJyc7XG5cbiAgICBjb25zdCBidWNrZXQgPSB0aGlzLnByb3BzLmJ1Y2tldE5hbWU7XG5cbiAgICBjb25zdCBoYXNoID0gY29udGVudEhhc2goZGF0YSk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBgJHtoYXNofSR7czNLZXlTdWZmaXh9YDtcbiAgICBjb25zdCBrZXkgPSBgJHtzM0tleVByZWZpeH0ke2ZpbGVuYW1lfWA7XG4gICAgY29uc3QgdXJsID0gYHMzOi8vJHtidWNrZXR9LyR7a2V5fWA7XG5cbiAgICBkZWJ1ZyhgJHt1cmx9OiBjaGVja2luZyBpZiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIGlmIChhd2FpdCBvYmplY3RFeGlzdHMoczMsIGJ1Y2tldCwga2V5KSkge1xuICAgICAgZGVidWcoYCR7dXJsfTogZm91bmQgKHNraXBwaW5nIHVwbG9hZClgKTtcbiAgICAgIHJldHVybiB7IGZpbGVuYW1lLCBrZXksIGhhc2gsIGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkZWQgPSB7IGZpbGVuYW1lLCBrZXksIGhhc2gsIGNoYW5nZWQ6IHRydWUgfTtcblxuICAgIC8vIFVwbG9hZCBpZiBpdCdzIG5ldyBvciBzZXJ2ZXItc2lkZSBjb3B5IGlmIGl0IHdhcyBhbHJlYWR5IHVwbG9hZGVkIHByZXZpb3VzbHlcbiAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNVcGxvYWRzW2hhc2hdO1xuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgZGVidWcoYCR7dXJsfTogY29weWluZ2ApO1xuICAgICAgYXdhaXQgczMuY29weU9iamVjdCh7XG4gICAgICAgIEJ1Y2tldDogYnVja2V0LFxuICAgICAgICBLZXk6IGtleSxcbiAgICAgICAgQ29weVNvdXJjZTogYCR7YnVja2V0fS8ke3ByZXZpb3VzLmtleX1gXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiBjb3B5IGNvbXBsZXRlYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKGAke3VybH06IHVwbG9hZGluZ2ApO1xuICAgICAgYXdhaXQgczMucHV0T2JqZWN0KHtcbiAgICAgICAgQnVja2V0OiBidWNrZXQsXG4gICAgICAgIEtleToga2V5LFxuICAgICAgICBCb2R5OiBkYXRhLFxuICAgICAgICBDb250ZW50VHlwZTogcHJvcHMuY29udGVudFR5cGVcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgIGRlYnVnKGAke3VybH06IHVwbG9hZCBjb21wbGV0ZWApO1xuICAgICAgdGhpcy5wcmV2aW91c1VwbG9hZHNbaGFzaF0gPSB1cGxvYWRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBsb2FkZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbiBFQ1IgcmVwb3NpdG9yeSBmb3IgdXBsb2FkaW5nIHRvIHVzaW5nIERvY2tlclxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHJlcGFyZUVjclJlcG9zaXRvcnkoYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5KTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz4ge1xuICAgIGNvbnN0IGVjciA9IGF3YWl0IHRoaXMucHJvcHMuc2RrLmVjcih0aGlzLnByb3BzLmVudmlyb25tZW50LmFjY291bnQsIHRoaXMucHJvcHMuZW52aXJvbm1lbnQucmVnaW9uLCBNb2RlLkZvcldyaXRpbmcpO1xuICAgIGxldCByZXBvc2l0b3J5TmFtZTtcbiAgICBpZiAoYXNzZXQucmVwb3NpdG9yeU5hbWUpIHtcbiAgICAgIC8vIFJlcG9zaXRvcnkgbmFtZSBwcm92aWRlZCBieSB1c2VyXG4gICAgICByZXBvc2l0b3J5TmFtZSA9IGFzc2V0LnJlcG9zaXRvcnlOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXBvc2l0b3J5IG5hbWUgYmFzZWQgb24gYXNzZXQgaWRcbiAgICAgIGNvbnN0IGFzc2V0SWQgPSBhc3NldC5pZDtcbiAgICAgIHJlcG9zaXRvcnlOYW1lID0gJ2Nkay8nICsgYXNzZXRJZC5yZXBsYWNlKC9bOi9dL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsZXQgcmVwb3NpdG9yeTtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBmb3IgcmVwb3NpdG9yeS5gKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlUmVzcG9uc2UgPSBhd2FpdCBlY3IuZGVzY3JpYmVSZXBvc2l0b3JpZXMoeyByZXBvc2l0b3J5TmFtZXM6IFtyZXBvc2l0b3J5TmFtZV0gfSkucHJvbWlzZSgpO1xuICAgICAgcmVwb3NpdG9yeSA9IGRlc2NyaWJlUmVzcG9uc2UucmVwb3NpdG9yaWVzIVswXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgaWYgKHJlcG9zaXRvcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcG9zaXRvcnlVcmk6IHJlcG9zaXRvcnkucmVwb3NpdG9yeVVyaSEsXG4gICAgICAgIHJlcG9zaXRvcnlOYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY3JlYXRpbmdgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjci5jcmVhdGVSZXBvc2l0b3J5KHsgcmVwb3NpdG9yeU5hbWUgfSkucHJvbWlzZSgpO1xuICAgIHJlcG9zaXRvcnkgPSByZXNwb25zZS5yZXBvc2l0b3J5ITtcblxuICAgIC8vIEJldHRlciBwdXQgYSBsaWZlY3ljbGUgcG9saWN5IG9uIHRoaXMgc28gYXMgdG8gbm90IGNvc3QgdG9vIG11Y2ggbW9uZXlcbiAgICBhd2FpdCBlY3IucHV0TGlmZWN5Y2xlUG9saWN5KHtcbiAgICAgIHJlcG9zaXRvcnlOYW1lLFxuICAgICAgbGlmZWN5Y2xlUG9saWN5VGV4dDogSlNPTi5zdHJpbmdpZnkoREVGQVVMVF9SRVBPX0xJRkVDWUNMRSlcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAvLyBDb25maWd1cmUgaW1hZ2Ugc2Nhbm5pbmcgb24gcHVzaCAoaGVscHMgaW4gaWRlbnRpZnlpbmcgc29mdHdhcmUgdnVsbmVyYWJpbGl0aWVzLCBubyBhZGRpdGlvbmFsIGNoYXJnZSlcbiAgICBhd2FpdCBlY3IucHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb24oe1xuICAgICAgcmVwb3NpdG9yeU5hbWUsXG4gICAgICBpbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICBzY2FuT25QdXNoOiB0cnVlXG4gICAgICB9XG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcG9zaXRvcnlVcmk6IHJlcG9zaXRvcnkucmVwb3NpdG9yeVVyaSEsXG4gICAgICByZXBvc2l0b3J5TmFtZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IEVDUiBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEVjckNyZWRlbnRpYWxzKCk6IFByb21pc2U8RWNyQ3JlZGVudGlhbHM+IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5lY3IodGhpcy5wcm9wcy5lbnZpcm9ubWVudC5hY2NvdW50LCB0aGlzLnByb3BzLmVudmlyb25tZW50LnJlZ2lvbiwgTW9kZS5Gb3JSZWFkaW5nKTtcblxuICAgIGRlYnVnKGBGZXRjaGluZyBFQ1IgYXV0aG9yaXphdGlvbiB0b2tlbmApO1xuICAgIGNvbnN0IGF1dGhEYXRhID0gIChhd2FpdCBlY3IuZ2V0QXV0aG9yaXphdGlvblRva2VuKHsgfSkucHJvbWlzZSgpKS5hdXRob3JpemF0aW9uRGF0YSB8fCBbXTtcbiAgICBpZiAoYXV0aERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhvcml6YXRpb24gZGF0YSByZWNlaXZlZCBmcm9tIEVDUicpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGF1dGhEYXRhWzBdLmF1dGhvcml6YXRpb25Ub2tlbiEsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBjb25zdCBbdXNlcm5hbWUsIHBhc3N3b3JkXSA9IHRva2VuLnNwbGl0KCc6Jyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGVuZHBvaW50OiBhdXRoRGF0YVswXS5wcm94eUVuZHBvaW50ISxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGltYWdlIGFscmVhZHkgZXhpc3RzIGluIEVDUiByZXBvc2l0b3J5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY2hlY2tFY3JJbWFnZShyZXBvc2l0b3J5TmFtZTogc3RyaW5nLCBpbWFnZVRhZzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdGhpcy5wcm9wcy5zZGsuZWNyKHRoaXMucHJvcHMuZW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5wcm9wcy5lbnZpcm9ubWVudC5yZWdpb24sIE1vZGUuRm9yUmVhZGluZyk7XG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBmb3IgaW1hZ2UgJHtpbWFnZVRhZ31gKTtcbiAgICAgIGF3YWl0IGVjci5kZXNjcmliZUltYWdlcyh7IHJlcG9zaXRvcnlOYW1lLCBpbWFnZUlkczogW3sgaW1hZ2VUYWcgfV0gfSkucHJvbWlzZSgpO1xuXG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlIGltYWdlIGFscmVhZHkgZXhpc3RzLiBOb3RoaW5nIGVsc2UgbmVlZHMgdG8gYmUgZG9uZS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdJbWFnZU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIEVjclJlcG9zaXRvcnlJbmZvIHtcbiAgcmVwb3NpdG9yeVVyaTogc3RyaW5nO1xuICByZXBvc2l0b3J5TmFtZTogc3RyaW5nO1xufVxuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBFY3JDcmVkZW50aWFscyB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9iamVjdEV4aXN0cyhzMzogYXdzLlMzLCBidWNrZXQ6IHN0cmluZywga2V5OiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzMy5oZWFkT2JqZWN0KHsgQnVja2V0OiBidWNrZXQsIEtleToga2V5IH0pLnByb21pc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdOb3RGb3VuZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRvb2xraXRJbmZvKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBJU0RLLCBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8VG9vbGtpdEluZm8gfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgY2ZuID0gYXdhaXQgc2RrLmNsb3VkRm9ybWF0aW9uKGVudmlyb25tZW50LmFjY291bnQsIGVudmlyb25tZW50LnJlZ2lvbiwgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCB3YWl0Rm9yU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgZGVidWcoJ1RoZSBlbnZpcm9ubWVudCAlcyBkb2VzblxcJ3QgaGF2ZSB0aGUgQ0RLIHRvb2xraXQgc3RhY2sgKCVzKSBpbnN0YWxsZWQuIFVzZSAlcyB0byBzZXR1cCB5b3VyIGVudmlyb25tZW50IGZvciB1c2Ugd2l0aCB0aGUgdG9vbGtpdC4nLFxuICAgICAgICBlbnZpcm9ubWVudC5uYW1lLCBzdGFja05hbWUsIGNvbG9ycy5ibHVlKGBjZGsgYm9vdHN0cmFwIFwiJHtlbnZpcm9ubWVudC5uYW1lfVwiYCkpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrLCBlbnZpcm9ubWVudCxcbiAgICBidWNrZXROYW1lOiBnZXRPdXRwdXRWYWx1ZShzdGFjaywgQlVDS0VUX05BTUVfT1VUUFVUKSxcbiAgICBidWNrZXRFbmRwb2ludDogZ2V0T3V0cHV0VmFsdWUoc3RhY2ssIEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRwdXRWYWx1ZShzdGFjazogYXdzLkNsb3VkRm9ybWF0aW9uLlN0YWNrLCBvdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZXN1bHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKHN0YWNrLk91dHB1dHMpIHtcbiAgICBjb25zdCBmb3VuZCA9IHN0YWNrLk91dHB1dHMuZmluZChvID0+IG8uT3V0cHV0S2V5ID09PSBvdXRwdXQpO1xuICAgIHJlc3VsdCA9IGZvdW5kICYmIGZvdW5kLk91dHB1dFZhbHVlO1xuICB9XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIENESyB0b29sa2l0IHN0YWNrICgke3N0YWNrLlN0YWNrTmFtZX0pIGRvZXMgbm90IGhhdmUgYW4gb3V0cHV0IG5hbWVkICR7b3V0cHV0fS4gVXNlICdjZGsgYm9vdHN0cmFwJyB0byBjb3JyZWN0IHRoaXMuYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVQT19MSUZFQ1lDTEUgPSB7XG4gIHJ1bGVzOiBbXG4gICAge1xuICAgICAgcnVsZVByaW9yaXR5OiAxMDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ1JldGFpbiBvbmx5IDUgaW1hZ2VzJyxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICB0YWdTdGF0dXM6ICdhbnknLFxuICAgICAgICBjb3VudFR5cGU6ICdpbWFnZUNvdW50TW9yZVRoYW4nLFxuICAgICAgICBjb3VudE51bWJlcjogNSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb246IHsgdHlwZTogJ2V4cGlyZScgfVxuICAgIH1cbiAgXVxufTtcbiJdfQ==