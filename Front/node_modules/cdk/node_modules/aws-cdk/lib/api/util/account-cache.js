"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const logging_1 = require("../../logging");
/**
 * Disk cache which maps access key IDs to account IDs.
 * Usage:
 *   cache.get(accessKey) => accountId | undefined
 *   cache.put(accessKey, accountId)
 */
class AccountAccessKeyCache {
    /**
     * @param filePath Path to the cache file
     */
    constructor(filePath) {
        this.cacheFile = filePath || path.join(os.homedir(), '.cdk', 'cache', 'accounts.json');
    }
    /**
     * Tries to fetch the account ID from cache. If it's not in the cache, invokes
     * the resolver function which should retrieve the account ID and return it.
     * Then, it will be stored into disk cache returned.
     *
     * Example:
     *
     *    const accountId = cache.fetch(accessKey, async () => {
     *      return await fetchAccountIdFromSomewhere(accessKey);
     *    });
     *
     * @param accessKeyId
     * @param resolver
     */
    async fetch(accessKeyId, resolver) {
        // try to get account ID based on this access key ID from disk.
        const cached = await this.get(accessKeyId);
        if (cached) {
            logging_1.debug(`Retrieved account ID ${cached} from disk cache`);
            return cached;
        }
        // if it's not in the cache, resolve and put in cache.
        const accountId = await resolver();
        if (accountId) {
            await this.put(accessKeyId, accountId);
        }
        return accountId;
    }
    /** Get the account ID from an access key or undefined if not in cache */
    async get(accessKeyId) {
        const map = await this.loadMap();
        return map[accessKeyId];
    }
    /** Put a mapping betweenn access key and account ID */
    async put(accessKeyId, accountId) {
        let map = await this.loadMap();
        // nuke cache if it's too big.
        if (Object.keys(map).length >= AccountAccessKeyCache.MAX_ENTRIES) {
            map = {};
        }
        map[accessKeyId] = accountId;
        await this.saveMap(map);
    }
    async loadMap() {
        if (!(await fs.pathExists(this.cacheFile))) {
            return {};
        }
        return await fs.readJson(this.cacheFile);
    }
    async saveMap(map) {
        if (!(await fs.pathExists(this.cacheFile))) {
            await fs.mkdirs(path.dirname(this.cacheFile));
        }
        await fs.writeJson(this.cacheFile, map, { spaces: 2 });
    }
}
exports.AccountAccessKeyCache = AccountAccessKeyCache;
/**
 * Max number of entries in the cache, after which the cache will be reset.
 */
AccountAccessKeyCache.MAX_ENTRIES = 1000;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC1jYWNoZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFjY291bnQtY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQkFBZ0M7QUFDaEMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQUM5QiwyQ0FBc0M7QUFFdEM7Ozs7O0dBS0c7QUFDSCxNQUFhLHFCQUFxQjtJQVFoQzs7T0FFRztJQUNILFlBQVksUUFBaUI7UUFDM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNJLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBbUIsRUFBRSxRQUEyQztRQUNqRiwrREFBK0Q7UUFDL0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLElBQUksTUFBTSxFQUFFO1lBQ1YsZUFBSyxDQUFDLHdCQUF3QixNQUFNLGtCQUFrQixDQUFDLENBQUM7WUFDeEQsT0FBTyxNQUFNLENBQUM7U0FDZjtRQUVELHNEQUFzRDtRQUN0RCxNQUFNLFNBQVMsR0FBRyxNQUFNLFFBQVEsRUFBRSxDQUFDO1FBQ25DLElBQUksU0FBUyxFQUFFO1lBQ2IsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUN4QztRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCx5RUFBeUU7SUFDbEUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFtQjtRQUNsQyxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQyxPQUFPLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQsdURBQXVEO0lBQ2hELEtBQUssQ0FBQyxHQUFHLENBQUMsV0FBbUIsRUFBRSxTQUFpQjtRQUNyRCxJQUFJLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUUvQiw4QkFBOEI7UUFDOUIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxxQkFBcUIsQ0FBQyxXQUFXLEVBQUU7WUFDaEUsR0FBRyxHQUFHLEVBQUcsQ0FBQztTQUNYO1FBRUQsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztRQUM3QixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPO1FBQ25CLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRTtZQUMxQyxPQUFPLEVBQUcsQ0FBQztTQUNaO1FBRUQsT0FBTyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQXNDO1FBQzFELElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRTtZQUMxQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUMvQztRQUVELE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7O0FBL0VILHNEQWdGQztBQS9FQzs7R0FFRztBQUNvQixpQ0FBVyxHQUFHLElBQUksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCdvcycpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuXG4vKipcbiAqIERpc2sgY2FjaGUgd2hpY2ggbWFwcyBhY2Nlc3Mga2V5IElEcyB0byBhY2NvdW50IElEcy5cbiAqIFVzYWdlOlxuICogICBjYWNoZS5nZXQoYWNjZXNzS2V5KSA9PiBhY2NvdW50SWQgfCB1bmRlZmluZWRcbiAqICAgY2FjaGUucHV0KGFjY2Vzc0tleSwgYWNjb3VudElkKVxuICovXG5leHBvcnQgY2xhc3MgQWNjb3VudEFjY2Vzc0tleUNhY2hlIHtcbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2FjaGUsIGFmdGVyIHdoaWNoIHRoZSBjYWNoZSB3aWxsIGJlIHJlc2V0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBNQVhfRU5UUklFUyA9IDEwMDA7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZUZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogQHBhcmFtIGZpbGVQYXRoIFBhdGggdG8gdGhlIGNhY2hlIGZpbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGVQYXRoPzogc3RyaW5nKSB7XG4gICAgdGhpcy5jYWNoZUZpbGUgPSBmaWxlUGF0aCB8fCBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCAnLmNkaycsICdjYWNoZScsICdhY2NvdW50cy5qc29uJyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gZmV0Y2ggdGhlIGFjY291bnQgSUQgZnJvbSBjYWNoZS4gSWYgaXQncyBub3QgaW4gdGhlIGNhY2hlLCBpbnZva2VzXG4gICAqIHRoZSByZXNvbHZlciBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0cmlldmUgdGhlIGFjY291bnQgSUQgYW5kIHJldHVybiBpdC5cbiAgICogVGhlbiwgaXQgd2lsbCBiZSBzdG9yZWQgaW50byBkaXNrIGNhY2hlIHJldHVybmVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICBjb25zdCBhY2NvdW50SWQgPSBjYWNoZS5mZXRjaChhY2Nlc3NLZXksIGFzeW5jICgpID0+IHtcbiAgICogICAgICByZXR1cm4gYXdhaXQgZmV0Y2hBY2NvdW50SWRGcm9tU29tZXdoZXJlKGFjY2Vzc0tleSk7XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gYWNjZXNzS2V5SWRcbiAgICogQHBhcmFtIHJlc29sdmVyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZmV0Y2goYWNjZXNzS2V5SWQ6IHN0cmluZywgcmVzb2x2ZXI6ICgpID0+IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPikge1xuICAgIC8vIHRyeSB0byBnZXQgYWNjb3VudCBJRCBiYXNlZCBvbiB0aGlzIGFjY2VzcyBrZXkgSUQgZnJvbSBkaXNrLlxuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHRoaXMuZ2V0KGFjY2Vzc0tleUlkKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBkZWJ1ZyhgUmV0cmlldmVkIGFjY291bnQgSUQgJHtjYWNoZWR9IGZyb20gZGlzayBjYWNoZWApO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBpbiB0aGUgY2FjaGUsIHJlc29sdmUgYW5kIHB1dCBpbiBjYWNoZS5cbiAgICBjb25zdCBhY2NvdW50SWQgPSBhd2FpdCByZXNvbHZlcigpO1xuICAgIGlmIChhY2NvdW50SWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucHV0KGFjY2Vzc0tleUlkLCBhY2NvdW50SWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50SWQ7XG4gIH1cblxuICAvKiogR2V0IHRoZSBhY2NvdW50IElEIGZyb20gYW4gYWNjZXNzIGtleSBvciB1bmRlZmluZWQgaWYgbm90IGluIGNhY2hlICovXG4gIHB1YmxpYyBhc3luYyBnZXQoYWNjZXNzS2V5SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgbWFwID0gYXdhaXQgdGhpcy5sb2FkTWFwKCk7XG4gICAgcmV0dXJuIG1hcFthY2Nlc3NLZXlJZF07XG4gIH1cblxuICAvKiogUHV0IGEgbWFwcGluZyBiZXR3ZWVubiBhY2Nlc3Mga2V5IGFuZCBhY2NvdW50IElEICovXG4gIHB1YmxpYyBhc3luYyBwdXQoYWNjZXNzS2V5SWQ6IHN0cmluZywgYWNjb3VudElkOiBzdHJpbmcpIHtcbiAgICBsZXQgbWFwID0gYXdhaXQgdGhpcy5sb2FkTWFwKCk7XG5cbiAgICAvLyBudWtlIGNhY2hlIGlmIGl0J3MgdG9vIGJpZy5cbiAgICBpZiAoT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPj0gQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTKSB7XG4gICAgICBtYXAgPSB7IH07XG4gICAgfVxuXG4gICAgbWFwW2FjY2Vzc0tleUlkXSA9IGFjY291bnRJZDtcbiAgICBhd2FpdCB0aGlzLnNhdmVNYXAobWFwKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZE1hcCgpOiBQcm9taXNlPHsgW2FjY2Vzc0tleUlkOiBzdHJpbmddOiBzdHJpbmcgfT4ge1xuICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHModGhpcy5jYWNoZUZpbGUpKSkge1xuICAgICAgcmV0dXJuIHsgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZnMucmVhZEpzb24odGhpcy5jYWNoZUZpbGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlTWFwKG1hcDogeyBbYWNjZXNzS2V5SWQ6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyh0aGlzLmNhY2hlRmlsZSkpKSB7XG4gICAgICBhd2FpdCBmcy5ta2RpcnMocGF0aC5kaXJuYW1lKHRoaXMuY2FjaGVGaWxlKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgZnMud3JpdGVKc29uKHRoaXMuY2FjaGVGaWxlLCBtYXAsIHsgc3BhY2VzOiAyIH0pO1xuICB9XG59XG4iXX0=