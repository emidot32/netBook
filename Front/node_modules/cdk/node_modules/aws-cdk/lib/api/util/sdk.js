"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 *
 * @experimental
 */
class SDK {
    constructor(options = {}) {
        /**
         * Default retry options for SDK clients
         *
         * Biggest bottleneck is CloudFormation, with a 1tps call rate. We want to be
         * a little more tenacious than the defaults, and with a little more breathing
         * room between calls (defaults are {retries=3, base=100}).
         *
         * I've left this running in a tight loop for an hour and the throttle errors
         * haven't escaped the retry mechanism.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        // Find the package.json from the main toolkit
        const pkg = require.main.require('../package.json');
        AWS.config.update({
            customUserAgent: `${pkg.name}/${pkg.version}`
        });
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        if (options.proxyAddress === undefined) {
            options.proxyAddress = httpsProxyFromEnvironment();
        }
        if (options.proxyAddress) { // Ignore empty string on purpose
            logging_1.debug('Using proxy server: %s', options.proxyAddress);
            AWS.config.update({
                httpOptions: { agent: require('proxy-agent')(options.proxyAddress) }
            });
        }
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegionGetter(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    async cloudFormation(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.CloudFormation({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ec2(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.EC2({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ssm(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.SSM({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async s3(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.S3({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async route53(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.Route53({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode),
        });
    }
    async ecr(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.ECR({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegionGetter(this.profile)();
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
    async resolveEnvironment(account, region) {
        if (region === cxapi.UNKNOWN_REGION) {
            region = await this.defaultRegion();
        }
        if (account === cxapi.UNKNOWN_ACCOUNT) {
            account = await this.defaultAccount();
        }
        if (!region) {
            throw new Error(`AWS region must be configured either when you configure your CDK stack or through the environment`);
        }
        if (!account) {
            throw new Error(`Unable to resolve AWS account to use. It must be either configured when you define your CDK or through the environment`);
        }
        const environment = {
            region, account, name: cxapi.EnvironmentUtils.format(account, region)
        };
        return environment;
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount || awsAccountId === cxapi.UNKNOWN_ACCOUNT) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region() }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 *
 * Returns a function that can be invoked to retrieve the actual region value
 * (used to be just a promise, but that would lead to firing off a failing
 * operation and if it was never awaited NodeJS would complain).
 */
function getCLICompatibleDefaultRegionGetter(profile) {
    let retrieved = false;
    let region;
    return async () => {
        if (!retrieved) {
            profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
            // Defaults inside constructor
            const toCheck = [
                { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
                { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
            ];
            region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
                process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
            while (!region && toCheck.length > 0) {
                const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
                const section = await configFile.getProfile(profile);
                region = section && section.region;
            }
            if (!region) {
                const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
                logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}`);
            }
            retrieved = true;
        }
        return region;
    };
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, await readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
async function readIfPossible(filename) {
    try {
        if (!await fs.pathExists(filename)) {
            return undefined;
        }
        return fs.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLCtCQUFnQztBQUNoQywrQ0FBZ0Q7QUFDaEQsK0JBQWdDO0FBQ2hDLHlCQUEwQjtBQUMxQiw2QkFBOEI7QUFDOUIsNkJBQThCO0FBQzlCLDJDQUFzQztBQUN0Qyx5Q0FBMEM7QUFFMUMsbURBQXdEO0FBQ3hELGlEQUErQztBQThDL0M7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQWEsR0FBRztJQWlCZCxZQUFZLFVBQXNCLEVBQUU7UUFacEM7Ozs7Ozs7OztXQVNHO1FBQ2MsaUJBQVksR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUMsQ0FBQztRQUdqRixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFFL0IsTUFBTSx5QkFBeUIsR0FBRyxtQ0FBbUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV6Ryw4Q0FBOEM7UUFDOUMsTUFBTSxHQUFHLEdBQUksT0FBTyxDQUFDLElBQVksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM3RCxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUNkLGVBQWUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtTQUNoRCxDQUFDLENBQUM7UUFFSCwrRkFBK0Y7UUFDL0YsSUFBSSxPQUFPLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxPQUFPLENBQUMsWUFBWSxHQUFHLHlCQUF5QixFQUFFLENBQUM7U0FDcEQ7UUFDRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxpQ0FBaUM7WUFDM0QsZUFBSyxDQUFDLHdCQUF3QixFQUFFLE9BQU8sQ0FBQyxZ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SyxVQUFVLGNBQWMsQ0FBQyxRQUFnQjtJQUM1QyxJQUFJO1FBQ0YsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sU0FBUyxDQUFDO1NBQUU7UUFDekQsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQ3JEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixlQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDVCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxFQUFVLEVBQUUsQ0FBcUI7SUFDckQsT0FBTyxDQUFDLEtBQUssU0FBUyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDO0FBQ2hELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCBBV1MgPSByZXF1aXJlKCdhd3Mtc2RrJyk7XG5pbXBvcnQgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCdvcycpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBQbHVnaW5Ib3N0IH0gZnJvbSAnLi4vLi4vcGx1Z2luJztcbmltcG9ydCB7IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSwgTW9kZSB9IGZyb20gJy4uL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEFjY291bnRBY2Nlc3NLZXlDYWNoZSB9IGZyb20gJy4vYWNjb3VudC1jYWNoZSc7XG5pbXBvcnQgeyBTaGFyZWRJbmlGaWxlIH0gZnJvbSAnLi9zZGtfaW5pX2ZpbGUnO1xuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBJU0RLIHtcbiAgY2xvdWRGb3JtYXRpb24oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uPjtcblxuICBlYzIoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkVDMj47XG5cbiAgc3NtKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TU00+O1xuXG4gIHMzKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TMz47XG5cbiAgcm91dGU1MyhhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuUm91dGU1Mz47XG5cbiAgZWNyKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5FQ1I+O1xuXG4gIGRlZmF1bHRSZWdpb24oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuXG4gIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTREtPcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb2ZpbGUgbmFtZSB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJvZmlsZVxuICAgKi9cbiAgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogUHJveHkgYWRkcmVzcyB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJveHlcbiAgICovXG4gIHByb3h5QWRkcmVzcz86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgdHJ5IGluc3RhbmNlIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIFRydWUvZmFsc2UgdG8gZm9yY2UvZGlzYWJsZS4gRGVmYXVsdCBpcyB0byBndWVzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgQXV0b21hdGljYWxseSBkZXRlcm1pbmUuXG4gICAqL1xuICBlYzJjcmVkcz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogU291cmNlIGZvciBTREsgY2xpZW50IG9iamVjdHNcbiAqXG4gKiBDcmVkZW50aWFscyBhcmUgZmlyc3Qgb2J0YWluZWQgZnJvbSB0aGUgU0RLIGRlZmF1bHRzICh1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHRoZVxuICogfi8uYXdzL3tjb25maWcsY3JlZGVudGlhbHN9IGZpbGVzKS5cbiAqXG4gKiBJZiB0aG9zZSBkb24ndCBzdWZmaWNlLCBhIGxpc3Qgb2YgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlcyBpcyBpbnRlcnJvZ2F0ZWQgZm9yIGFjY2Vzc1xuICogdG8gdGhlIHJlcXVlc3RlZCBhY2NvdW50LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIFNESyBpbXBsZW1lbnRzIElTREsge1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRBd3NBY2NvdW50OiBEZWZhdWx0QVdTQWNjb3VudDtcbiAgcHJpdmF0ZSByZWFkb25seSBjcmVkZW50aWFsc0NhY2hlOiBDcmVkZW50aWFsc0NhY2hlO1xuICBwcml2YXRlIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmV0cnkgb3B0aW9ucyBmb3IgU0RLIGNsaWVudHNcbiAgICpcbiAgICogQmlnZ2VzdCBib3R0bGVuZWNrIGlzIENsb3VkRm9ybWF0aW9uLCB3aXRoIGEgMXRwcyBjYWxsIHJhdGUuIFdlIHdhbnQgdG8gYmVcbiAgICogYSBsaXR0bGUgbW9yZSB0ZW5hY2lvdXMgdGhhbiB0aGUgZGVmYXVsdHMsIGFuZCB3aXRoIGEgbGl0dGxlIG1vcmUgYnJlYXRoaW5nXG4gICAqIHJvb20gYmV0d2VlbiBjYWxscyAoZGVmYXVsdHMgYXJlIHtyZXRyaWVzPTMsIGJhc2U9MTAwfSkuXG4gICAqXG4gICAqIEkndmUgbGVmdCB0aGlzIHJ1bm5pbmcgaW4gYSB0aWdodCBsb29wIGZvciBhbiBob3VyIGFuZCB0aGUgdGhyb3R0bGUgZXJyb3JzXG4gICAqIGhhdmVuJ3QgZXNjYXBlZCB0aGUgcmV0cnkgbWVjaGFuaXNtLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDYsIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDMwMCB9fTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTREtPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGU7XG5cbiAgICBjb25zdCBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyID0gbWFrZUNMSUNvbXBhdGlibGVDcmVkZW50aWFsUHJvdmlkZXIob3B0aW9ucy5wcm9maWxlLCBvcHRpb25zLmVjMmNyZWRzKTtcblxuICAgIC8vIEZpbmQgdGhlIHBhY2thZ2UuanNvbiBmcm9tIHRoZSBtYWluIHRvb2xraXRcbiAgICBjb25zdCBwa2cgPSAocmVxdWlyZS5tYWluIGFzIGFueSkucmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG4gICAgQVdTLmNvbmZpZy51cGRhdGUoe1xuICAgICAgICBjdXN0b21Vc2VyQWdlbnQ6IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufWBcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vYmxvZ3MvZGV2ZWxvcGVyL3VzaW5nLXRoZS1hd3Mtc2RrLWZvci1qYXZhc2NyaXB0LWZyb20tYmVoaW5kLWEtcHJveHkvXG4gICAgaWYgKG9wdGlvbnMucHJveHlBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMucHJveHlBZGRyZXNzID0gaHR0cHNQcm94eUZyb21FbnZpcm9ubWVudCgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcm94eUFkZHJlc3MpIHsgLy8gSWdub3JlIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICBkZWJ1ZygnVXNpbmcgcHJveHkgc2VydmVyOiAlcycsIG9wdGlvbnMucHJveHlBZGRyZXNzKTtcbiAgICAgIEFXUy5jb25maWcudXBkYXRlKHtcbiAgICAgICAgaHR0cE9wdGlvbnM6IHsgYWdlbnQ6IHJlcXVpcmUoJ3Byb3h5LWFnZW50Jykob3B0aW9ucy5wcm94eUFkZHJlc3MpIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdEF3c0FjY291bnQgPSBuZXcgRGVmYXVsdEFXU0FjY291bnQoZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlciwgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIodGhpcy5wcm9maWxlKSk7XG4gICAgdGhpcy5jcmVkZW50aWFsc0NhY2hlID0gbmV3IENyZWRlbnRpYWxzQ2FjaGUodGhpcy5kZWZhdWx0QXdzQWNjb3VudCwgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvdWRGb3JtYXRpb24oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLkNsb3VkRm9ybWF0aW9uKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGVjMihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLkVDMih7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzc20oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlNTTT4ge1xuICAgIGNvbnN0IGVudmlyb25tZW50ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW52aXJvbm1lbnQoYWNjb3VudCwgcmVnaW9uKTtcbiAgICByZXR1cm4gbmV3IEFXUy5TU00oe1xuICAgICAgLi4udGhpcy5yZXRyeU9wdGlvbnMsXG4gICAgICByZWdpb246IGVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGVudmlyb25tZW50LmFjY291bnQsIG1vZGUpXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgczMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlMzPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLlMzKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJvdXRlNTMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+IHtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGFjY291bnQsIHJlZ2lvbik7XG4gICAgcmV0dXJuIG5ldyBBV1MuUm91dGU1Myh7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZWNyKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5FQ1I+IHtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGFjY291bnQsIHJlZ2lvbik7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUNSKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlZmF1bHRSZWdpb24oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIodGhpcy5wcm9maWxlKSgpO1xuICB9XG5cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF3c0FjY291bnQuZ2V0KCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCApIHtcbiAgICBpZiAocmVnaW9uID09PSBjeGFwaS5VTktOT1dOX1JFR0lPTikge1xuICAgICAgcmVnaW9uID0gYXdhaXQgdGhpcy5kZWZhdWx0UmVnaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKGFjY291bnQgPT09IGN4YXBpLlVOS05PV05fQUNDT1VOVCkge1xuICAgICAgYWNjb3VudCA9IGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBV1MgcmVnaW9uIG11c3QgYmUgY29uZmlndXJlZCBlaXRoZXIgd2hlbiB5b3UgY29uZmlndXJlIHlvdXIgQ0RLIHN0YWNrIG9yIHRocm91Z2ggdGhlIGVudmlyb25tZW50YCk7XG4gICAgfVxuXG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIEFXUyBhY2NvdW50IHRvIHVzZS4gSXQgbXVzdCBiZSBlaXRoZXIgY29uZmlndXJlZCB3aGVuIHlvdSBkZWZpbmUgeW91ciBDREsgb3IgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQgPSB7XG4gICAgICByZWdpb24sIGFjY291bnQsIG5hbWU6IGN4YXBpLkVudmlyb25tZW50VXRpbHMuZm9ybWF0KGFjY291bnQsIHJlZ2lvbilcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVudmlyb25tZW50O1xuICB9XG5cbn1cblxuLyoqXG4gKiBDYWNoZSBmb3IgY3JlZGVudGlhbCBwcm92aWRlcnMuXG4gKlxuICogR2l2ZW4gYW4gYWNjb3VudCBhbmQgYW4gb3BlcmF0aW5nIG1vZGUgKHJlYWQgb3Igd3JpdGUpIHdpbGwgcmV0dXJuIGFuXG4gKiBhcHByb3ByaWF0ZSBjcmVkZW50aWFsIHByb3ZpZGVyIGZvciBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQuIFRoZVxuICogY3JlZGVudGlhbCBwcm92aWRlciB3aWxsIGJlIGNhY2hlZCBzbyB0aGF0IG11bHRpcGxlIEFXUyBjbGllbnRzIGZvciB0aGUgc2FtZVxuICogZW52aXJvbm1lbnQgd2lsbCBub3QgbWFrZSBtdWx0aXBsZSBuZXR3b3JrIGNhbGxzIHRvIG9idGFpbiBjcmVkZW50aWFscy5cbiAqXG4gKiBXaWxsIHVzZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZXkgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudDsgb3RoZXJ3aXNlLFxuICogYWxsIGxvYWRlZCBjcmVkZW50aWFsIHByb3ZpZGVyIHBsdWdpbnMgd2lsbCBiZSB0cmllZCB0byBvYnRhaW4gY3JlZGVudGlhbHNcbiAqIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC5cbiAqL1xuY2xhc3MgQ3JlZGVudGlhbHNDYWNoZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGU6IHtba2V5OiBzdHJpbmddOiBBV1MuQ3JlZGVudGlhbHN9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF3c0FjY291bnQ6IERlZmF1bHRBV1NBY2NvdW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcjogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4+KSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5nZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzPiB7XG4gICAgLy8gSWYgcmVxdWVzdGVkIGFjY291bnQgaXMgdW5kZWZpbmVkIG9yIGVxdWFsIHRvIGRlZmF1bHQgYWNjb3VudCwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXIuXG4gICAgLy8gKE5vdGUgdGhhdCB3ZSBpZ25vcmUgdGhlIG1vZGUgaW4gdGhpcyBjYXNlLCBpZiB5b3UgcHJlbG9hZGVkIGNyZWRlbnRpYWxzIHRoZXkgYmV0dGVyIGJlIGNvcnJlY3QhKVxuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50ID0gYXdhaXQgdGhpcy5kZWZhdWx0QXdzQWNjb3VudC5nZXQoKTtcbiAgICBpZiAoIWF3c0FjY291bnRJZCB8fCBhd3NBY2NvdW50SWQgPT09IGRlZmF1bHRBY2NvdW50IHx8IGF3c0FjY291bnRJZCA9PT0gY3hhcGkuVU5LTk9XTl9BQ0NPVU5UKSB7XG4gICAgICBkZWJ1ZyhgVXNpbmcgZGVmYXVsdCBBV1MgU0RLIGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuXG4gICAgICAvLyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiBleHRlbmRzIENyZWRlbnRpYWxzLCBidXQgdGhhdCBpcyBhIGxpZS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMjIzNVxuICAgICAgLy8gQ2FsbCByZXNvbHZlKCkgaW5zdGVhZC5cbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyKS5yZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaWVkU291cmNlczogQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlW10gPSBbXTtcbiAgICAvLyBPdGhlcndpc2UsIGluc3BlY3QgdGhlIHZhcmlvdXMgY3JlZGVudGlhbCBzb3VyY2VzIHdlIGhhdmVcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBQbHVnaW5Ib3N0Lmluc3RhbmNlLmNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMpIHtcbiAgICAgIGlmICghKGF3YWl0IHNvdXJjZS5pc0F2YWlsYWJsZSgpKSkge1xuICAgICAgICBkZWJ1ZygnQ3JlZGVudGlhbHMgc291cmNlICVzIGlzIG5vdCBhdmFpbGFibGUsIGlnbm9yaW5nIGl0LicsIHNvdXJjZS5uYW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmllZFNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmNhblByb3ZpZGVDcmVkZW50aWFscyhhd3NBY2NvdW50SWQpKSkgeyBjb250aW51ZTsgfVxuICAgICAgZGVidWcoYFVzaW5nICR7c291cmNlLm5hbWV9IGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuICAgICAgY29uc3QgcHJvdmlkZXJPckNyZWRzID0gYXdhaXQgc291cmNlLmdldFByb3ZpZGVyKGF3c0FjY291bnRJZCwgbW9kZSk7XG5cbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiB0aGUgcGx1Z2luIHJldHVybnMgYSBQcm92aWRlckNoYWluLCByZXNvbHZlIHRoYXQgY2hhaW4uXG4gICAgICAvLyBPdGhlcndpc2UgaXQgbXVzdCBoYXZlIHJldHVybmVkIGNyZWRlbnRpYWxzLlxuICAgICAgaWYgKChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvdmlkZXJPckNyZWRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VOYW1lcyA9IFsnZGVmYXVsdCBjcmVkZW50aWFscyddLmNvbmNhdCh0cmllZFNvdXJjZXMubWFwKHMgPT4gcy5uYW1lKSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5lZWQgdG8gcGVyZm9ybSBBV1MgY2FsbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9LCBidXQgbm8gY3JlZGVudGlhbHMgZm91bmQuIFRyaWVkOiAke3NvdXJjZU5hbWVzfS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHRvIHJldHJpZXZlIHRoZSBhY2NvdW50IGZvciBkZWZhdWx0IGNyZWRlbnRpYWxzIGFuZCBjYWNoZSBpdC5cbiAqXG4gKiBVc2VzIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRvIG9idGFpbiBjcmVkZW50aWFscyAoaWYgYXZhaWxhYmxlKSxcbiAqIGFuZCB1c2VzIHRob3NlIGNyZWRlbnRpYWxzIHRvIGNhbGwgU1RTIHRvIHJlcXVlc3QgdGhlIGN1cnJlbnQgYWNjb3VudCBJRC5cbiAqXG4gKiBUaGUgY3JlZGVudGlhbHMgPT4gYWNjb3VudElkIGxvb2t1cCBpcyBjYWNoZWQgb24gZGlzaywgc2luY2UgaXQnc1xuICogZ3VhcmFudGVlZCB0aGF0IGlndmVuIGFjY2VzcyBrZXkgd2lsbCBhbHdheXMgcmVtYWluIGZvciB0aGUgc2FtZSBhY2NvdW50LlxuICovXG5jbGFzcyBEZWZhdWx0QVdTQWNjb3VudCB7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRGZXRjaGVkID0gZmFsc2U7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRJZD86IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2NvdW50Q2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDcmVkZW50aWFsc1Byb3ZpZGVyOiBQcm9taXNlPEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbj4sXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGFjY291bnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMuZGVmYXVsdEFjY291bnRGZXRjaGVkKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50SWQgPSBhd2FpdCB0aGlzLmxvb2t1cERlZmF1bHRBY2NvdW50KCk7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50RmV0Y2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY2NvdW50SWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cERlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlIGp1c3QgaXMgKk5PKiB3YXkgdG8gZG8gQXNzdW1lUm9sZSBjcmVkZW50aWFscyBhcyBsb25nIGFzIEFXU19TREtfTE9BRF9DT05GSUcgaXMgbm90IHNldC4gVGhlIFNES1xuICAgICAgLy8gY3Jhc2ggaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QgdGhvdWdoLiBTbyBzZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHdlIGNhbiBmaW5kIHRoYXQgZmlsZS5cbiAgICAgIGF3YWl0IHNldENvbmZpZ1ZhcmlhYmxlKCk7XG5cbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgY29uc3QgY3JlZGVudGlhbFByb3ZpZGVyID0gYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmVQcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICBpZiAoIWFjY2Vzc0tleUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlc29sdmUgQVdTIGNyZWRlbnRpYWxzIChzZXR1cCB3aXRoIFwiYXdzIGNvbmZpZ3VyZVwiKScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50SWQgPSBhd2FpdCB0aGlzLmFjY291bnRDYWNoZS5mZXRjaChjcmVkcy5hY2Nlc3NLZXlJZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIG9uZSwgcmVzb2x2ZSBmcm9tIFNUUyBhbmQgc3RvcmUgaW4gY2FjaGUuXG4gICAgICAgIGRlYnVnKCdMb29raW5nIHVwIGRlZmF1bHQgYWNjb3VudCBJRCBmcm9tIFNUUycpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgQVdTLlNUUyh7IGNyZWRlbnRpYWxzOiBjcmVkcywgcmVnaW9uOiBhd2FpdCB0aGlzLnJlZ2lvbigpIH0pLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgICAgICBjb25zdCBhaWQgPSByZXN1bHQuQWNjb3VudDtcbiAgICAgICAgaWYgKCFhaWQpIHtcbiAgICAgICAgICBkZWJ1ZygnU1RTIGRpZG5cXCd0IHJldHVybiBhbiBhY2NvdW50IElEJyk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnRGVmYXVsdCBhY2NvdW50IElEOicsIGFpZCk7XG4gICAgICAgIHJldHVybiBhaWQ7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFjY291bnRJZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnVW5hYmxlIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBBV1MgYWNjb3VudCAoZGlkIHlvdSBjb25maWd1cmUgXCJhd3MgY29uZmlndXJlXCI/KTonLCBlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAqXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiBjcmVhdGVkIGJ5IHRoZSBTREtcbiAqIGV4Y2VwdCBpdCBhbHNvIGFjY2VwdHMgdGhlIHByb2ZpbGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yIChub3QganVzdCBmcm9tXG4gKiB0aGUgZW52aXJvbm1lbnQpLlxuICpcbiAqIFRvIG1pbWljIHRoZSBBV1MgQ0xJIGJlaGF2aW9yOlxuICpcbiAqIC0gd2UgZGVmYXVsdCB0byB+Ly5hd3MvY3JlZGVudGlhbHMgaWYgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIGNyZWRlbnRpYWxzXG4gKiBmaWxlIGxvY2F0aW9uIGlzIG5vdCBnaXZlbiAoU0RLIGV4cGVjdHMgZXhwbGljaXQgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCBuYW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBpcyBhbHNvIGluc3BlY3RlZCBmb3IgcHJvZmlsZSBuYW1lIChub3QganVzdCBBV1NfUFJPRklMRSkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VDTElDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZWMyY3JlZHM6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgcHJvZmlsZSA9IHByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgLy8gTmVlZCB0byBjb25zdHJ1Y3QgZmlsZW5hbWUgb3Vyc2VsdmVzLCB3aXRob3V0IGFwcHJvcHJpYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAvLyBubyBkZWZhdWx0cyB1c2VkIGJ5IEpTIFNESy5cbiAgY29uc3QgZmlsZW5hbWUgPSBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfHwgcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJy5hd3MnLCAnY3JlZGVudGlhbHMnKTtcblxuICBjb25zdCBzb3VyY2VzID0gW1xuICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyksXG4gICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKSxcbiAgXTtcbiAgaWYgKGZzLnBhdGhFeGlzdHMoZmlsZW5hbWUpKSB7XG4gICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHsgcHJvZmlsZSwgZmlsZW5hbWUgfSkpO1xuICB9XG5cbiAgaWYgKGhhc0Vjc0NyZWRlbnRpYWxzKCkpIHtcbiAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQ1NDcmVkZW50aWFscygpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIGlmOiBkb24ndCBnZXQgRUMyIGNyZWRzIGlmIHdlIHNob3VsZCBoYXZlIGdvdHRlbiBFQ1MgY3JlZHMtLUVDUyBpbnN0YW5jZXMgYWxzb1xuICAgIC8vIHJ1biBvbiBFQzIgYm94ZXMgYnV0IHRoZSBjcmVkcyByZXByZXNlbnQgc29tZXRoaW5nIGRpZmZlcmVudC4gU2FtZSBiZWhhdmlvciBhc1xuICAgIC8vIHVwc3RyZWFtIGNvZGUuXG5cbiAgICBpZiAoZWMyY3JlZHMgPT09IHVuZGVmaW5lZCkgeyBlYzJjcmVkcyA9IGF3YWl0IGhhc0VjMkNyZWRlbnRpYWxzKCk7IH1cblxuICAgIGlmIChlYzJjcmVkcykge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihzb3VyY2VzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZmF1bHQgcmVnaW9uIGluIGEgQ0xJLWNvbXBhdGlibGUgd2F5XG4gKlxuICogTW9zdGx5IGNvcGllZCBmcm9tIG5vZGVfbG9hZGVyLmpzLCBidXQgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICpcbiAqIC0gVGFrZXMgYSBydW50aW1lIHByb2ZpbGUgbmFtZSB0byBsb2FkIHRoZSByZWdpb24gZnJvbSwgbm90IGp1c3QgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIGF0IHByb2Nlc3Mgc3RhcnQuXG4gKiAtIFdlIGhhdmUgbmVlZGVkIHRvIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIFNoYXJlZEluaUZpbGUgY2xhc3MgYmVjYXVzZSB0aGVcbiAqICAgaW1wbGVtZW50YXRpb24gaW4gJ2F3cy1zZGsnIGlzIHByaXZhdGUgKGFuZCB0aGUgZGVmYXVsdCB1c2Ugb2YgaXQgaW4gdGhlXG4gKiAgIFNESyBkb2VzIG5vdCBhbGxvdyB1cyB0byBzcGVjaWZ5IGEgcHJvZmlsZSBhdCBydW50aW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBhbmQgQVdTX0RFRkFVTFRfUkVHSU9OIGFyZSBhbHNvIHVzZWQgYXMgZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIHRvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWdpb24uXG4gKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gcmV0cmlldmUgdGhlIGFjdHVhbCByZWdpb24gdmFsdWVcbiAqICh1c2VkIHRvIGJlIGp1c3QgYSBwcm9taXNlLCBidXQgdGhhdCB3b3VsZCBsZWFkIHRvIGZpcmluZyBvZmYgYSBmYWlsaW5nXG4gKiBvcGVyYXRpb24gYW5kIGlmIGl0IHdhcyBuZXZlciBhd2FpdGVkIE5vZGVKUyB3b3VsZCBjb21wbGFpbikuXG4gKi9cbmZ1bmN0aW9uIGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uR2V0dGVyKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCk6ICgpID0+IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGxldCByZXRyaWV2ZWQgPSBmYWxzZTtcbiAgbGV0IHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghcmV0cmlldmVkKSB7XG4gICAgICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgICAgLy8gRGVmYXVsdHMgaW5zaWRlIGNvbnN0cnVjdG9yXG4gICAgICBjb25zdCB0b0NoZWNrID0gW1xuICAgICAgICB7ZmlsZW5hbWU6IHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB9LFxuICAgICAgICB7aXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEV9LFxuICAgICAgXTtcblxuICAgICAgcmVnaW9uID0gcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fUkVHSU9OIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT047XG5cbiAgICAgIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjb25maWdGaWxlID0gbmV3IFNoYXJlZEluaUZpbGUodG9DaGVjay5zaGlmdCgpKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGF3YWl0IGNvbmZpZ0ZpbGUuZ2V0UHJvZmlsZShwcm9maWxlKTtcbiAgICAgICAgcmVnaW9uID0gc2VjdGlvbiAmJiBzZWN0aW9uLnJlZ2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgY29uc3QgdXNlZFByb2ZpbGUgPSAhcHJvZmlsZSA/ICcnIDogYCAocHJvZmlsZTogXCIke3Byb2ZpbGV9XCIpYDtcbiAgICAgICAgZGVidWcoYFVuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJlZ2lvbiBmcm9tIGVudmlyb25tZW50IG9yIEFXUyBjb25maWd1cmF0aW9uJHt1c2VkUHJvZmlsZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0cmlldmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaW9uO1xuICB9O1xufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgY29uZmlndXJlZCBIVFRQUyBwcm94eSBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGh0dHBzUHJveHlGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5KSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5IVFRQU19QUk9YWSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGl0IGxvb2tzIGxpa2Ugd2UnbGwgaGF2ZSBFQ1MgY3JlZGVudGlhbHMgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGhhc0Vjc0NyZWRlbnRpYWxzKCkge1xuICByZXR1cm4gKEFXUy5FQ1NDcmVkZW50aWFscy5wcm90b3R5cGUgYXMgYW55KS5pc0NvbmZpZ3VyZWRGb3JFY3NDcmVkZW50aWFscygpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBoYXNFYzJDcmVkZW50aWFscygpIHtcbiAgZGVidWcoXCJEZXRlcm1pbmluZyB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZS5cIik7XG5cbiAgbGV0IGluc3RhbmNlID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvV2luZG93c0d1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHV0aWwucHJvbWlzaWZ5KGNoaWxkX3Byb2Nlc3MuZXhlYykoJ3dtaWMgcGF0aCB3aW4zMl9jb21wdXRlcnN5c3RlbXByb2R1Y3QgZ2V0IHV1aWQnLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIC8vIG91dHB1dCBsb29rcyBsaWtlXG4gICAgLy8gIFVVSURcbiAgICAvLyAgRUMyQUUxNDUtRDFEQy0xM0IyLTk0RUQtMDEyMzRBQkNERUZcbiAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgaW5zdGFuY2UgPSBsaW5lcy5zb21lKHggPT4gbWF0Y2hlc1JlZ2V4KC9eZWMyL2ksIHgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9Vc2VyR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PFtzdHJpbmcsIFJlZ0V4cF0+ID0gW1xuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBYZW4gaHlwZXJ2aXNvciBiYXNlZCBpbnN0YW5jZXMgKHByZS01dGggZ2VuKVxuICAgICAgWycvc3lzL2h5cGVydmlzb3IvdXVpZCcsIC9eZWMyL2ldLFxuXG4gICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIG5ldyBIeXBlcnZpc29yICg1dGgtZ2VuIGluc3RhbmNlcyBhbmQgaGlnaGVyKVxuICAgICAgLy8gQ2FuJ3QgdXNlIHRoZSBhZHZlcnRpc2VkIGZpbGUgJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3V1aWQnIGJlY2F1c2UgaXQgcmVxdWlyZXMgcm9vdCB0byByZWFkLlxuICAgICAgLy8gSW5zdGVhZCwgc3lzX3ZlbmRvciBjb250YWlucyBzb21ldGhpbmcgbGlrZSAnQW1hem9uIEVDMicuXG4gICAgICBbJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9zeXNfdmVuZG9yJywgL2VjMi9pXSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2ZpbGUsIHJlXSBvZiBmaWxlcykge1xuICAgICAgaWYgKG1hdGNoZXNSZWdleChyZSwgYXdhaXQgcmVhZElmUG9zc2libGUoZmlsZSkpKSB7XG4gICAgICAgIGluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVidWcoaW5zdGFuY2UgPyAnTG9va3MgbGlrZSBFQzIgaW5zdGFuY2UuJyA6ICdEb2VzIG5vdCBsb29rIGxpa2UgRUMyIGluc3RhbmNlLicpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldENvbmZpZ1ZhcmlhYmxlKCkge1xuICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRVxuICAgIHx8IChwcm9jZXNzLmVudi5IT01FUEFUSCA/ICgocHJvY2Vzcy5lbnYuSE9NRURSSVZFIHx8ICdDOi8nKSArIHByb2Nlc3MuZW52LkhPTUVQQVRIKSA6IG51bGwpIHx8IG9zLmhvbWVkaXIoKTtcblxuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLnJlc29sdmUoaG9tZURpciwgJy5hd3MnLCAnY29uZmlnJykpKSB7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NES19MT0FEX0NPTkZJRyA9ICcxJztcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSWZQb3NzaWJsZShmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhlKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXNSZWdleChyZTogUmVnRXhwLCBzOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHMgIT09IHVuZGVmaW5lZCAmJiByZS5leGVjKHMpICE9PSBudWxsO1xufVxuIl19