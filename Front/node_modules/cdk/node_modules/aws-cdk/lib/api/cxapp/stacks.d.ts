import cxapi = require('@aws-cdk/cx-api');
import { Configuration } from '../../settings';
import { ISDK } from '../util/sdk';
/**
 * @returns output directory
 */
declare type Synthesizer = (aws: ISDK, config: Configuration) => Promise<cxapi.CloudAssembly>;
export interface AppStacksProps {
    /**
     * Whether to be verbose
     *
     * @default false
     */
    verbose?: boolean;
    /**
     * Don't stop on error metadata
     *
     * @default false
     */
    ignoreErrors?: boolean;
    /**
     * Treat warnings in metadata as errors
     *
     * @default false
     */
    strict?: boolean;
    /**
     * Application configuration (settings and context)
     */
    configuration: Configuration;
    /**
     * AWS object (used by synthesizer and contextprovider)
     */
    aws: ISDK;
    /**
     * Callback invoked to synthesize the actual stacks
     */
    synthesizer: Synthesizer;
}
export interface SelectStacksOptions {
    /**
     * Extend the selection to upstread/downstream stacks
     * @default ExtendedStackSelection.None only select the specified stacks.
     */
    extend?: ExtendedStackSelection;
    /**
     * The behavior if if no selectors are privided.
     */
    defaultBehavior: DefaultSelection;
}
export declare enum DefaultSelection {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    None = "none",
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    OnlySingle = "single",
    /**
     * If no selectors are provided, returns all stacks in the app.
     */
    AllStacks = "all"
}
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
export declare class AppStacks {
    private readonly props;
    /**
     * Since app execution basically always synthesizes all the stacks,
     * we can invoke it once and cache the response for subsequent calls.
     */
    assembly?: cxapi.CloudAssembly;
    constructor(props: AppStacksProps);
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    selectStacks(selectors: string[], options: SelectStacksOptions): Promise<cxapi.CloudFormationStackArtifact[]>;
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     */
    listStacks(): Promise<cxapi.CloudFormationStackArtifact[]>;
    /**
     * Synthesize a single stack
     */
    synthesizeStack(stackId: string): Promise<cxapi.CloudFormationStackArtifact>;
    /**
     * Synthesize a set of stacks
     */
    synthesizeStacks(): Promise<cxapi.CloudAssembly>;
    /**
     * @returns an array with the tags available in the stack metadata.
     */
    getTagsFromStackMetadata(stack: cxapi.CloudFormationStackArtifact): Tag[];
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadata(stacks: cxapi.CloudFormationStackArtifact[]): void;
    private printMessage;
}
/**
 * Combine the names of a set of stacks using a comma
 */
export declare function listStackIds(stacks: cxapi.CloudFormationStackArtifact[]): string;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
export declare enum ExtendedStackSelection {
    /**
     * Don't select any extra stacks
     */
    None = 0,
    /**
     * Include stacks that this stack depends on
     */
    Upstream = 1,
    /**
     * Include stacks that depend on this stack
     */
    Downstream = 2
}
export interface SelectedStack extends cxapi.CloudFormationStackArtifact {
    /**
     * The original name of the stack before renaming
     */
    originalName: string;
}
export interface Tag {
    readonly Key: string;
    readonly Value: string;
}
export {};
