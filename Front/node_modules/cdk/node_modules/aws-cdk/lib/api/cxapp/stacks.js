"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const region_info_1 = require("@aws-cdk/region-info");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const arrays_1 = require("../../util/arrays");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * If no selectors are provided, returns all stacks in the app.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection = exports.DefaultSelection || (exports.DefaultSelection = {}));
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
class AppStacks {
    constructor(props) {
        this.props = props;
    }
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    async selectStacks(selectors, options) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = await this.listStacks();
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            switch (options.defaultBehavior) {
                case DefaultSelection.AllStacks:
                    return stacks;
                case DefaultSelection.None:
                    return [];
                case DefaultSelection.OnlySingle:
                    if (stacks.length === 1) {
                        return stacks;
                    }
                    else {
                        throw new Error(`Since this app includes more than a single stack, specify which stacks to use (wildcards are supported)\n` +
                            `Stacks: ${stacks.map(x => x.id).join(' ')}`);
                    }
                default:
                    throw new Error(`invalid default behavior: ${options.defaultBehavior}`);
            }
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.id, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.id, pattern) && !selectedStacks.has(stack.id)) {
                    selectedStacks.set(stack.id, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        const extend = options.extend || ExtendedStackSelection.None;
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.id));
        return selectedList;
    }
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     */
    async listStacks() {
        const response = await this.synthesizeStacks();
        return response.stacks;
    }
    /**
     * Synthesize a single stack
     */
    async synthesizeStack(stackId) {
        const resp = await this.synthesizeStacks();
        const stack = resp.getStackArtifact(stackId);
        return stack;
    }
    /**
     * Synthesize a set of stacks
     */
    async synthesizeStacks() {
        if (this.assembly) {
            return this.assembly;
        }
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.aws, this.props.configuration);
            if (assembly.manifest.missing) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    logging_1.debug(`Not making progress trying to resolve environmental context. Giving up.`);
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    logging_1.debug(`Some context information is missing. Fetching...`);
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.aws);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            if (trackVersions && assembly.runtime) {
                const modules = formatModules(assembly.runtime);
                for (const stack of assembly.stacks) {
                    if (!stack.template.Resources) {
                        stack.template.Resources = {};
                    }
                    const resourcePresent = stack.environment.region === cxapi.UNKNOWN_REGION
                        || region_info_1.RegionInfo.get(stack.environment.region).cdkMetadataResourceAvailable;
                    if (resourcePresent) {
                        if (!stack.template.Resources.CDKMetadata) {
                            stack.template.Resources.CDKMetadata = {
                                Type: 'AWS::CDK::Metadata',
                                Properties: {
                                    Modules: modules
                                }
                            };
                            if (stack.environment.region === cxapi.UNKNOWN_REGION) {
                                stack.template.Conditions = stack.template.Conditions || {};
                                const condName = 'CDKMetadataAvailable';
                                if (!stack.template.Conditions[condName]) {
                                    stack.template.Conditions[condName] = _makeCdkMetadataAvailableCondition();
                                    stack.template.Resources.CDKMetadata.Condition = condName;
                                }
                                else {
                                    logging_1.warning(`The stack ${stack.id} already includes a ${condName} condition`);
                                }
                            }
                        }
                        else {
                            logging_1.warning(`The stack ${stack.id} already includes a CDKMetadata resource`);
                        }
                    }
                }
            }
            // All good, return
            this.assembly = assembly;
            return assembly;
            function formatModules(runtime) {
                const modules = new Array();
                // inject toolkit version to list of modules
                const toolkitVersion = require('../../../package.json').version;
                modules.push(`aws-cdk=${toolkitVersion}`);
                for (const key of Object.keys(runtime.libraries).sort()) {
                    modules.push(`${key}=${runtime.libraries[key]}`);
                }
                return modules.join(',');
            }
        }
    }
    /**
     * @returns an array with the tags available in the stack metadata.
     */
    getTagsFromStackMetadata(stack) {
        return arrays_1.flatMap(stack.findMetadataByType(cxapi.STACK_TAGS_METADATA_KEY), x => x.data);
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadata(stacks) {
        let warnings = false;
        let errors = false;
        for (const stack of stacks) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cxapi.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        this.printMessage(logging_1.warning, 'Warning', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.ERROR:
                        errors = true;
                        this.printMessage(logging_1.error, 'Error', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.INFO:
                        this.printMessage(logging_1.print, 'Info', message.id, message.entry);
                        break;
                }
            }
        }
        if (errors && !this.props.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (this.props.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
    }
    printMessage(logFn, prefix, id, entry) {
        logFn(`[${prefix} at ${id}] ${entry.data}`);
        if (this.props.verbose && entry.trace) {
            logFn(`  ${entry.trace.join('\n  ')}`);
        }
    }
}
exports.AppStacks = AppStacks;
/**
 * Combine the names of a set of stacks using a comma
 */
function listStackIds(stacks) {
    return stacks.map(s => s.id).join(', ');
}
exports.listStackIds = listStackIds;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * Include stacks that depend on the stacks already in the set
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const [id, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(id) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(id, stack);
                added.push(id);
                madeProgress = true;
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Include stacks that that stacks in the set depend on
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyId of stack.dependencies.map(x => x.id)) {
                if (!selectedStacks.has(dependencyId) && allStacks.has(dependencyId)) {
                    added.push(dependencyId);
                    selectedStacks.set(dependencyId, allStacks.get(dependencyId));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Return all keys of misisng context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
function _makeCdkMetadataAvailableCondition() {
    return _fnOr(region_info_1.RegionInfo.regions
        .filter(ri => ri.cdkMetadataResourceAvailable)
        .map(ri => ({ 'Fn::Equals': [{ Ref: 'AWS::Region' }, ri.name] })));
}
/**
 * This takes a bunch of operands and crafts an `Fn::Or` for those. Funny thing is `Fn::Or` requires
 * at least 2 operands and at most 10 operands, so we have to... do this.
 */
function _fnOr(operands) {
    if (operands.length === 0) {
        throw new Error('Cannot build `Fn::Or` with zero operands!');
    }
    if (operands.length === 1) {
        return operands[0];
    }
    if (operands.length <= 10) {
        return { 'Fn::Or': operands };
    }
    return _fnOr(_inGroupsOf(operands, 10).map(group => _fnOr(group)));
}
function _inGroupsOf(array, maxGroup) {
    const result = new Array();
    for (let i = 0; i < array.length; i += maxGroup) {
        result.push(array.slice(i, i + maxGroup));
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLHNEQUFrRDtBQUNsRCxzQ0FBdUM7QUFDdkMsdUNBQXdDO0FBQ3hDLDREQUE2RDtBQUM3RCwyQ0FBNkQ7QUFFN0QsOENBQTRDO0FBMkQ1QyxJQUFZLGdCQWdCWDtBQWhCRCxXQUFZLGdCQUFnQjtJQUMxQjs7T0FFRztJQUNILGlDQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx5Q0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILHFDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFoQlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFnQjNCO0FBRUQ7Ozs7R0FJRztBQUNILE1BQWEsU0FBUztJQVFwQixZQUE2QixLQUFxQjtRQUFyQixVQUFLLEdBQUwsS0FBSyxDQUFnQjtJQUFHLENBQUM7SUFFdEQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsT0FBNEI7UUFDekUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFdEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzFCLFFBQVEsT0FBTyxDQUFDLGVBQWUsRUFBRTtnQkFDL0IsS0FBSyxnQkFBZ0IsQ0FBQyxTQUFTO29CQUM3QixPQUFPLE1BQU0sQ0FBQztnQkFDaEIsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJO29CQUN4QixP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QUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsS0FBSyxDQUFDLFFBQWU7SUFDNUIsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7S0FDOUQ7SUFDRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEVBQUUsRUFBRTtRQUN6QixPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDO0tBQy9CO0lBQ0QsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBSSxLQUFVLEVBQUUsUUFBZ0I7SUFDbEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQU8sQ0FBQztJQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksUUFBUSxFQUFFO1FBQy9DLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7S0FDM0M7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgeyBSZWdpb25JbmZvIH0gZnJvbSAnQGF3cy1jZGsvcmVnaW9uLWluZm8nO1xuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5pbXBvcnQgY29udGV4dHByb3ZpZGVycyA9IHJlcXVpcmUoJy4uLy4uL2NvbnRleHQtcHJvdmlkZXJzJyk7XG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IsIHByaW50LCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgZmxhdE1hcCB9IGZyb20gJy4uLy4uL3V0aWwvYXJyYXlzJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi91dGlsL3Nkayc7XG5cbi8qKlxuICogQHJldHVybnMgb3V0cHV0IGRpcmVjdG9yeVxuICovXG50eXBlIFN5bnRoZXNpemVyID0gKGF3czogSVNESywgY29uZmlnOiBDb25maWd1cmF0aW9uKSA9PiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFwcFN0YWNrc1Byb3BzIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYmUgdmVyYm9zZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERvbid0IHN0b3Agb24gZXJyb3IgbWV0YWRhdGFcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZUVycm9ycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyZWF0IHdhcm5pbmdzIGluIG1ldGFkYXRhIGFzIGVycm9yc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc3RyaWN0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBhd3M6IElTREs7XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgdG8gc3ludGhlc2l6ZSB0aGUgYWN0dWFsIHN0YWNrc1xuICAgKi9cbiAgc3ludGhlc2l6ZXI6IFN5bnRoZXNpemVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFN0YWNrc09wdGlvbnMge1xuICAvKipcbiAgICogRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdXBzdHJlYWQvZG93bnN0cmVhbSBzdGFja3NcbiAgICogQGRlZmF1bHQgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIG9ubHkgc2VsZWN0IHRoZSBzcGVjaWZpZWQgc3RhY2tzLlxuICAgKi9cbiAgZXh0ZW5kPzogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGJlaGF2aW9yIGlmIGlmIG5vIHNlbGVjdG9ycyBhcmUgcHJpdmlkZWQuXG4gICAqL1xuICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb247XG59XG5cbmV4cG9ydCBlbnVtIERlZmF1bHRTZWxlY3Rpb24ge1xuICAvKipcbiAgICogUmV0dXJucyBhbiBlbXB0eSBzZWxlY3Rpb24gaW4gY2FzZSB0aGVyZSBhcmUgbm8gc2VsZWN0b3JzLlxuICAgKi9cbiAgTm9uZSA9ICdub25lJyxcblxuICAvKipcbiAgICogSWYgdGhlIGFwcCBpbmNsdWRlcyBhIHNpbmdsZSBzdGFjaywgcmV0dXJucyBpdC4gT3RoZXJ3aXNlIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAqIFRoaXMgYmVoYXZpb3IgaXMgdXNlZCBieSBcImRlcGxveVwiLlxuICAgKi9cbiAgT25seVNpbmdsZSA9ICdzaW5nbGUnLFxuXG4gIC8qKlxuICAgKiBJZiBubyBzZWxlY3RvcnMgYXJlIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBzdGFja3MgaW4gdGhlIGFwcC5cbiAgICovXG4gIEFsbFN0YWNrcyA9ICdhbGwnLFxufVxuXG4vKipcbiAqIFJvdXRpbmVzIHRvIGdldCBzdGFja3MgZnJvbSBhbiBhcHBcbiAqXG4gKiBJbiBhIGNsYXNzIGJlY2F1c2UgaXQgc2hhcmVzIHNvbWUgZ2xvYmFsIHN0YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcHBTdGFja3Mge1xuXG4gIC8qKlxuICAgKiBTaW5jZSBhcHAgZXhlY3V0aW9uIGJhc2ljYWxseSBhbHdheXMgc3ludGhlc2l6ZXMgYWxsIHRoZSBzdGFja3MsXG4gICAqIHdlIGNhbiBpbnZva2UgaXQgb25jZSBhbmQgY2FjaGUgdGhlIHJlc3BvbnNlIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICAgKi9cbiAgcHVibGljIGFzc2VtYmx5PzogY3hhcGkuQ2xvdWRBc3NlbWJseTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBBcHBTdGFja3NQcm9wcykge31cblxuICAvKipcbiAgICogTGlzdCBhbGwgc3RhY2tzIGluIHRoZSBDWCBhbmQgcmV0dXJuIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAqXG4gICAqIEl0J3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIG5vIHN0YWNrcyB0byBzZWxlY3QsIG9yIGlmIG9uZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnNcbiAgICogcmVmZXJzIHRvIGEgbm9uZXhpc3RhbnQgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VsZWN0U3RhY2tzKHNlbGVjdG9yczogc3RyaW5nW10sIG9wdGlvbnM6IFNlbGVjdFN0YWNrc09wdGlvbnMpOiBQcm9taXNlPGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdPiB7XG4gICAgc2VsZWN0b3JzID0gc2VsZWN0b3JzLmZpbHRlcihzID0+IHMgIT0gbnVsbCk7IC8vIGZpbHRlciBudWxsL3VuZGVmaW5lZFxuXG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5saXN0U3RhY2tzKCk7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5kZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLkFsbFN0YWNrczpcbiAgICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uTm9uZTpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5Pbmx5U2luZ2xlOlxuICAgICAgICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbmNlIHRoaXMgYXBwIGluY2x1ZGVzIG1vcmUgdGhhbiBhIHNpbmdsZSBzdGFjaywgc3BlY2lmeSB3aGljaCBzdGFja3MgdG8gdXNlICh3aWxkY2FyZHMgYXJlIHN1cHBvcnRlZClcXG5gICtcbiAgICAgICAgICAgICAgYFN0YWNrczogJHtzdGFja3MubWFwKHggPT4geC5pZCkuam9pbignICcpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGVmYXVsdCBiZWhhdmlvcjogJHtvcHRpb25zLmRlZmF1bHRCZWhhdmlvcn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBhbGxTdGFja3Muc2V0KHN0YWNrLmlkLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGV2ZXJ5IHNlbGVjdG9yIGFyZ3VtZW50LCBwaWNrIHN0YWNrcyBmcm9tIHRoZSBsaXN0LlxuICAgIGNvbnN0IHNlbGVjdGVkU3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4oKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgaWYgKG1pbmltYXRjaChzdGFjay5pZCwgcGF0dGVybikgJiYgIXNlbGVjdGVkU3RhY2tzLmhhcyhzdGFjay5pZCkpIHtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoc3RhY2suaWQsIHN0YWNrKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YWNrIGZvdW5kIG1hdGNoaW5nICcke3BhdHRlcm59Jy4gVXNlIFwibGlzdFwiIHRvIHByaW50IG1hbmlmZXN0YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kID0gb3B0aW9ucy5leHRlbmQgfHwgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lO1xuICAgIHN3aXRjaCAoZXh0ZW5kKSB7XG4gICAgICBjYXNlIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uRG93bnN0cmVhbTpcbiAgICAgICAgaW5jbHVkZURvd25zdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3MsIGFsbFN0YWNrcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLlVwc3RyZWFtOlxuICAgICAgICBpbmNsdWRlVXBzdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3MsIGFsbFN0YWNrcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBvcmlnaW5hbCBhcnJheSBiZWNhdXNlIGl0IGlzIGluIHRoZSByaWdodCBvcmRlclxuICAgIGNvbnN0IHNlbGVjdGVkTGlzdCA9IHN0YWNrcy5maWx0ZXIocyA9PiBzZWxlY3RlZFN0YWNrcy5oYXMocy5pZCkpO1xuXG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHN0YWNrcyBpbiB0aGUgQ1hcbiAgICpcbiAgICogSWYgdGhlIHN0YWNrcyBoYXZlIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHRoZW0sIHRoZXkgd2lsbCBiZSByZXR1cm5lZCBpblxuICAgKiB0b3BvbG9naWNhbGx5IHNvcnRlZCBvcmRlci4gSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBub3QgaW4gdGhlXG4gICAqIHNldCwgdGhleSB3aWxsIGJlIGlnbm9yZWQ7IGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdGhhdCB0aGVcbiAgICogbm9uLXNlbGVjdGVkIHN0YWNrcyBoYXZlIGFscmVhZHkgYmVlbiBkZXBsb3llZCBwcmV2aW91c2x5LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zeW50aGVzaXplU3RhY2tzKCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnN0YWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2luZ2xlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZVN0YWNrKHN0YWNrSWQ6IHN0cmluZyk6IFByb21pc2U8Y3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuc3ludGhlc2l6ZVN0YWNrcygpO1xuICAgIGNvbnN0IHN0YWNrID0gcmVzcC5nZXRTdGFja0FydGlmYWN0KHN0YWNrSWQpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2V0IG9mIHN0YWNrc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoZXNpemVTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5DbG91ZEFzc2VtYmx5PiB7XG4gICAgaWYgKHRoaXMuYXNzZW1ibHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VtYmx5O1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrVmVyc2lvbnM6IGJvb2xlYW4gPSB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndmVyc2lvblJlcG9ydGluZyddKTtcblxuICAgIC8vIFdlIG1heSBuZWVkIHRvIHJ1biB0aGUgY2xvdWQgZXhlY3V0YWJsZSBtdWx0aXBsZSB0aW1lcyBpbiBvcmRlciB0byBzYXRpc2Z5IGFsbCBtaXNzaW5nIGNvbnRleHRcbiAgICBsZXQgcHJldmlvdXNseU1pc3NpbmdLZXlzOiBTZXQ8c3RyaW5nPiB8IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLnByb3BzLnN5bnRoZXNpemVyKHRoaXMucHJvcHMuYXdzLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZykge1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5cyA9IG1pc3NpbmdDb250ZXh0S2V5cyhhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nKTtcblxuICAgICAgICBsZXQgdHJ5TG9va3VwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzbHlNaXNzaW5nS2V5cyAmJiBzZXRzRXF1YWwobWlzc2luZ0tleXMsIHByZXZpb3VzbHlNaXNzaW5nS2V5cykpIHtcbiAgICAgICAgICBkZWJ1ZyhgTm90IG1ha2luZyBwcm9ncmVzcyB0cnlpbmcgdG8gcmVzb2x2ZSBlbnZpcm9ubWVudGFsIGNvbnRleHQuIEdpdmluZyB1cC5gKTtcbiAgICAgICAgICB0cnlMb29rdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzbHlNaXNzaW5nS2V5cyA9IG1pc3NpbmdLZXlzO1xuXG4gICAgICAgIGlmICh0cnlMb29rdXApIHtcbiAgICAgICAgICBkZWJ1ZyhgU29tZSBjb250ZXh0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcuIEZldGNoaW5nLi4uYCk7XG5cbiAgICAgICAgICBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcsIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5jb250ZXh0LCB0aGlzLnByb3BzLmF3cyk7XG5cbiAgICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IGNvbnRleHQgdG8gZGlza1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuXG4gICAgICAgICAgLy8gRXhlY3V0ZSBhZ2FpblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFja1ZlcnNpb25zICYmIGFzc2VtYmx5LnJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGZvcm1hdE1vZHVsZXMoYXNzZW1ibHkucnVudGltZSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2YgYXNzZW1ibHkuc3RhY2tzKSB7XG4gICAgICAgICAgaWYgKCFzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXNvdXJjZVByZXNlbnQgPSBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24gPT09IGN4YXBpLlVOS05PV05fUkVHSU9OXG4gICAgICAgICAgICB8fCBSZWdpb25JbmZvLmdldChzdGFjay5lbnZpcm9ubWVudC5yZWdpb24pLmNka01ldGFkYXRhUmVzb3VyY2VBdmFpbGFibGU7XG4gICAgICAgICAgaWYgKHJlc291cmNlUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKCFzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIFR5cGU6ICdBV1M6OkNESzo6TWV0YWRhdGEnLFxuICAgICAgICAgICAgICAgIFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgIE1vZHVsZXM6IG1vZHVsZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChzdGFjay5lbnZpcm9ubWVudC5yZWdpb24gPT09IGN4YXBpLlVOS05PV05fUkVHSU9OKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9ucyA9IHN0YWNrLnRlbXBsYXRlLkNvbmRpdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZE5hbWUgPSAnQ0RLTWV0YWRhdGFBdmFpbGFibGUnO1xuICAgICAgICAgICAgICAgIGlmICghc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9uc1tjb25kTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIHN0YWNrLnRlbXBsYXRlLkNvbmRpdGlvbnNbY29uZE5hbWVdID0gX21ha2VDZGtNZXRhZGF0YUF2YWlsYWJsZUNvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhLkNvbmRpdGlvbiA9IGNvbmROYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgc3RhY2sgJHtzdGFjay5pZH0gYWxyZWFkeSBpbmNsdWRlcyBhICR7Y29uZE5hbWV9IGNvbmRpdGlvbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybmluZyhgVGhlIHN0YWNrICR7c3RhY2suaWR9IGFscmVhZHkgaW5jbHVkZXMgYSBDREtNZXRhZGF0YSByZXNvdXJjZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGwgZ29vZCwgcmV0dXJuXG4gICAgICB0aGlzLmFzc2VtYmx5ID0gYXNzZW1ibHk7XG4gICAgICByZXR1cm4gYXNzZW1ibHk7XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE1vZHVsZXMocnVudGltZTogY3hhcGkuUnVudGltZUluZm8pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgICAgICAvLyBpbmplY3QgdG9vbGtpdCB2ZXJzaW9uIHRvIGxpc3Qgb2YgbW9kdWxlc1xuICAgICAgICBjb25zdCB0b29sa2l0VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgICAgIG1vZHVsZXMucHVzaChgYXdzLWNkaz0ke3Rvb2xraXRWZXJzaW9ufWApO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJ1bnRpbWUubGlicmFyaWVzKS5zb3J0KCkpIHtcbiAgICAgICAgICBtb2R1bGVzLnB1c2goYCR7a2V5fT0ke3J1bnRpbWUubGlicmFyaWVzW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZXMuam9pbignLCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0YWdzIGF2YWlsYWJsZSBpbiB0aGUgc3RhY2sgbWV0YWRhdGEuXG4gICAqL1xuICBwdWJsaWMgZ2V0VGFnc0Zyb21TdGFja01ldGFkYXRhKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBUYWdbXSB7XG4gICAgcmV0dXJuIGZsYXRNYXAoc3RhY2suZmluZE1ldGFkYXRhQnlUeXBlKGN4YXBpLlNUQUNLX1RBR1NfTUVUQURBVEFfS0VZKSwgeCA9PiB4LmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHB1YmxpYyBwcm9jZXNzTWV0YWRhdGEoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSkge1xuICAgIGxldCB3YXJuaW5ncyA9IGZhbHNlO1xuICAgIGxldCBlcnJvcnMgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2Ygc3RhY2subWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmxldmVsKSB7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuV0FSTklORzpcbiAgICAgICAgICAgIHdhcm5pbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKHdhcm5pbmcsICdXYXJuaW5nJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5FUlJPUjpcbiAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50TWVzc2FnZShlcnJvciwgJ0Vycm9yJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5JTkZPOlxuICAgICAgICAgICAgdGhpcy5wcmludE1lc3NhZ2UocHJpbnQsICdJbmZvJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgIXRoaXMucHJvcHMuaWdub3JlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLnN0cmljdCAmJiB3YXJuaW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB3YXJuaW5ncyAoLS1zdHJpY3QgbW9kZSknKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByaW50TWVzc2FnZShsb2dGbjogKHM6IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmcsIGlkOiBzdHJpbmcsIGVudHJ5OiBjeGFwaS5NZXRhZGF0YUVudHJ5KSB7XG4gICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHtpZH1dICR7ZW50cnkuZGF0YX1gKTtcblxuICAgIGlmICh0aGlzLnByb3BzLnZlcmJvc2UgJiYgZW50cnkudHJhY2UpIHtcbiAgICAgIGxvZ0ZuKGAgICR7ZW50cnkudHJhY2Uuam9pbignXFxuICAnKX1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaW5lIHRoZSBuYW1lcyBvZiBhIHNldCBvZiBzdGFja3MgdXNpbmcgYSBjb21tYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFN0YWNrSWRzKHN0YWNrczogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0W10pOiBzdHJpbmcge1xuICByZXR1cm4gc3RhY2tzLm1hcChzID0+IHMuaWQpLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogV2hlbiBzZWxlY3Rpbmcgc3RhY2tzLCB3aGF0IG90aGVyIHN0YWNrcyB0byBpbmNsdWRlIGJlY2F1c2Ugb2YgZGVwZW5kZW5jaWVzXG4gKi9cbmV4cG9ydCBlbnVtIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24ge1xuICAvKipcbiAgICogRG9uJ3Qgc2VsZWN0IGFueSBleHRyYSBzdGFja3NcbiAgICovXG4gIE5vbmUsXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgdGhpcyBzdGFjayBkZXBlbmRzIG9uXG4gICAqL1xuICBVcHN0cmVhbSxcblxuICAvKipcbiAgICogSW5jbHVkZSBzdGFja3MgdGhhdCBkZXBlbmQgb24gdGhpcyBzdGFja1xuICAgKi9cbiAgRG93bnN0cmVhbVxufVxuXG4vKipcbiAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoZSBzdGFja3MgYWxyZWFkeSBpbiB0aGUgc2V0XG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZURvd25zdHJlYW1TdGFja3MoXG4gICAgc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4sXG4gICAgYWxsU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBsZXQgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgd2hpbGUgKG1hZGVQcm9ncmVzcykge1xuICAgIG1hZGVQcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBbaWQsIHN0YWNrXSBvZiBhbGxTdGFja3MpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGlzIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBBTkQgaXQgZGVwZW5kcyBvbiBhIHN0YWNrIHRoYXQncyBpbiB0aGUgc2VsZWN0ZWQgc2V0XG4gICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhpZCkgJiYgKHN0YWNrLmRlcGVuZGVuY2llcyB8fCBbXSkuc29tZShkZXAgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKGRlcC5pZCkpKSB7XG4gICAgICAgIHNlbGVjdGVkU3RhY2tzLnNldChpZCwgc3RhY2spO1xuICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kaW5nIHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoYXQgc3RhY2tzIGluIHRoZSBzZXQgZGVwZW5kIG9uXG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVVwc3RyZWFtU3RhY2tzKFxuICAgIHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+LFxuICAgIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lJZCBvZiBzdGFjay5kZXBlbmRlbmNpZXMubWFwKHggPT4geC5pZCkpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFN0YWNrcy5oYXMoZGVwZW5kZW5jeUlkKSAmJiBhbGxTdGFja3MuaGFzKGRlcGVuZGVuY3lJZCkpIHtcbiAgICAgICAgICBhZGRlZC5wdXNoKGRlcGVuZGVuY3lJZCk7XG4gICAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KGRlcGVuZGVuY3lJZCwgYWxsU3RhY2tzLmdldChkZXBlbmRlbmN5SWQpISk7XG4gICAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgcHJpbnQoJ0luY2x1ZGluZyBkZXBlbmRlbmN5IHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RlZFN0YWNrIGV4dGVuZHMgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBzdGFjayBiZWZvcmUgcmVuYW1pbmdcbiAgICovXG4gIG9yaWdpbmFsTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZyB7XG4gIHJlYWRvbmx5IEtleTogc3RyaW5nO1xuICByZWFkb25seSBWYWx1ZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybiBhbGwga2V5cyBvZiBtaXNpc25nIGNvbnRleHQgaXRlbXNcbiAqL1xuZnVuY3Rpb24gbWlzc2luZ0NvbnRleHRLZXlzKG1pc3Npbmc/OiBjeGFwaS5NaXNzaW5nQ29udGV4dFtdKTogU2V0PHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFNldCgobWlzc2luZyB8fCBbXSkubWFwKG0gPT4gbS5rZXkpKTtcbn1cblxuZnVuY3Rpb24gc2V0c0VxdWFsPEE+KGE6IFNldDxBPiwgYjogU2V0PEE+KSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZm9yIChjb25zdCB4IG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKHgpKSB7IHJldHVybiBmYWxzZTsgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfbWFrZUNka01ldGFkYXRhQXZhaWxhYmxlQ29uZGl0aW9uKCkge1xuICByZXR1cm4gX2ZuT3IoUmVnaW9uSW5mby5yZWdpb25zXG4gICAgLmZpbHRlcihyaSA9PiByaS5jZGtNZXRhZGF0YVJlc291cmNlQXZhaWxhYmxlKVxuICAgIC5tYXAocmkgPT4gKHsgJ0ZuOjpFcXVhbHMnOiBbeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgcmkubmFtZV0gfSkpKTtcbn1cblxuLyoqXG4gKiBUaGlzIHRha2VzIGEgYnVuY2ggb2Ygb3BlcmFuZHMgYW5kIGNyYWZ0cyBhbiBgRm46Ok9yYCBmb3IgdGhvc2UuIEZ1bm55IHRoaW5nIGlzIGBGbjo6T3JgIHJlcXVpcmVzXG4gKiBhdCBsZWFzdCAyIG9wZXJhbmRzIGFuZCBhdCBtb3N0IDEwIG9wZXJhbmRzLCBzbyB3ZSBoYXZlIHRvLi4uIGRvIHRoaXMuXG4gKi9cbmZ1bmN0aW9uIF9mbk9yKG9wZXJhbmRzOiBhbnlbXSk6IGFueSB7XG4gIGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBidWlsZCBgRm46Ok9yYCB3aXRoIHplcm8gb3BlcmFuZHMhJyk7XG4gIH1cbiAgaWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvcGVyYW5kc1swXTtcbiAgfVxuICBpZiAob3BlcmFuZHMubGVuZ3RoIDw9IDEwKSB7XG4gICAgcmV0dXJuIHsgJ0ZuOjpPcic6IG9wZXJhbmRzIH07XG4gIH1cbiAgcmV0dXJuIF9mbk9yKF9pbkdyb3Vwc09mKG9wZXJhbmRzLCAxMCkubWFwKGdyb3VwID0+IF9mbk9yKGdyb3VwKSkpO1xufVxuXG5mdW5jdGlvbiBfaW5Hcm91cHNPZjxUPihhcnJheTogVFtdLCBtYXhHcm91cDogbnVtYmVyKTogVFtdW10ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8VFtdPigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBtYXhHcm91cCkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGksIGkgKyBtYXhHcm91cCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=