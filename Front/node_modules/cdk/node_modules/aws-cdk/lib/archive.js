"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const crypto = require("crypto");
const fs = require("fs-extra");
const glob = require("glob");
const path = require("path");
function zipDirectory(directory, outputFile) {
    return new Promise(async (ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = fs.createWriteStream(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        archive.pipe(output);
        // Append files serially to ensure file order
        for (const file of files) {
            const fullPath = path.join(directory, file);
            const [data, stat] = await Promise.all([fs.readFile(fullPath), fs.stat(fullPath)]);
            archive.append(data, {
                name: file,
                date: new Date('1980-01-01T00:00:00.000Z'),
                mode: stat.mode,
            });
        }
        archive.finalize();
        // archive has been finalized and the output file descriptor has closed, resolve promise
        output.once('close', () => ok());
    });
}
exports.zipDirectory = zipDirectory;
function contentHash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}
exports.contentHash = contentHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBc0M7QUFDdEMsaUNBQWtDO0FBQ2xDLCtCQUFnQztBQUNoQyw2QkFBOEI7QUFDOUIsNkJBQThCO0FBRTlCLFNBQWdCLFlBQVksQ0FBQyxTQUFpQixFQUFFLFVBQWtCO0lBQ2hFLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUNwQyxzRkFBc0Y7UUFDdEYsaUZBQWlGO1FBQ2pGLGlFQUFpRTtRQUNqRSxNQUFNLFdBQVcsR0FBRztZQUNsQixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLElBQUk7WUFDWixHQUFHLEVBQUUsU0FBUztTQUNmLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLG9DQUFvQztRQUVoRixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFaEQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVCLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsNkNBQTZDO1FBQzdDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3hCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRixPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtnQkFDbkIsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDO2dCQUMxQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7YUFDaEIsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFbkIsd0ZBQXdGO1FBQ3hGLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbkMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBcENELG9DQW9DQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxJQUFnQztJQUMxRCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBRkQsa0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJjaGl2ZXIgPSByZXF1aXJlKCdhcmNoaXZlcicpO1xuaW1wb3J0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmltcG9ydCBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXBEaXJlY3RvcnkoZGlyZWN0b3J5OiBzdHJpbmcsIG91dHB1dEZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKG9rLCBmYWlsKSA9PiB7XG4gICAgLy8gVGhlIGJlbG93IG9wdGlvbnMgYXJlIG5lZWRlZCB0byBzdXBwb3J0IGZvbGxvd2luZyBzeW1saW5rcyB3aGVuIGJ1aWxkaW5nIHppcCBmaWxlczpcbiAgICAvLyAtIG5vZGlyOiBUaGlzIHdpbGwgcHJldmVudCBzeW1saW5rcyB0aGVtc2VsdmVzIGZyb20gYmVpbmcgY29waWVkIGludG8gdGhlIHppcC5cbiAgICAvLyAtIGZvbGxvdzogVGhpcyB3aWxsIGZvbGxvdyBzeW1saW5rcyBhbmQgY29weSB0aGUgZmlsZXMgd2l0aGluLlxuICAgIGNvbnN0IGdsb2JPcHRpb25zID0ge1xuICAgICAgZG90OiB0cnVlLFxuICAgICAgbm9kaXI6IHRydWUsXG4gICAgICBmb2xsb3c6IHRydWUsXG4gICAgICBjd2Q6IGRpcmVjdG9yeSxcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzID0gZ2xvYi5zeW5jKCcqKicsIGdsb2JPcHRpb25zKTsgLy8gVGhlIG91dHB1dCBoZXJlIGlzIGFscmVhZHkgc29ydGVkXG5cbiAgICBjb25zdCBvdXRwdXQgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXRGaWxlKTtcblxuICAgIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJyk7XG4gICAgYXJjaGl2ZS5vbignd2FybmluZycsIGZhaWwpO1xuICAgIGFyY2hpdmUub24oJ2Vycm9yJywgZmFpbCk7XG4gICAgYXJjaGl2ZS5waXBlKG91dHB1dCk7XG5cbiAgICAvLyBBcHBlbmQgZmlsZXMgc2VyaWFsbHkgdG8gZW5zdXJlIGZpbGUgb3JkZXJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgZmlsZSk7XG4gICAgICBjb25zdCBbZGF0YSwgc3RhdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbZnMucmVhZEZpbGUoZnVsbFBhdGgpLCBmcy5zdGF0KGZ1bGxQYXRoKV0pO1xuICAgICAgYXJjaGl2ZS5hcHBlbmQoZGF0YSwge1xuICAgICAgICBuYW1lOiBmaWxlLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgnMTk4MC0wMS0wMVQwMDowMDowMC4wMDBaJyksIC8vIHJlc2V0IGRhdGVzIHRvIGdldCB0aGUgc2FtZSBoYXNoIGZvciB0aGUgc2FtZSBjb250ZW50XG4gICAgICAgIG1vZGU6IHN0YXQubW9kZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAgIC8vIGFyY2hpdmUgaGFzIGJlZW4gZmluYWxpemVkIGFuZCB0aGUgb3V0cHV0IGZpbGUgZGVzY3JpcHRvciBoYXMgY2xvc2VkLCByZXNvbHZlIHByb21pc2VcbiAgICBvdXRwdXQub25jZSgnY2xvc2UnLCAoKSA9PiBvaygpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250ZW50SGFzaChkYXRhOiBzdHJpbmcgfCBCdWZmZXIgfCBEYXRhVmlldykge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufVxuIl19