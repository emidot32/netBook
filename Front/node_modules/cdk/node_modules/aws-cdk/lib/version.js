"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const colors = require("colors/safe");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const semver = require("semver");
const util_1 = require("util");
const logging_1 = require("../lib/logging");
const console_formatters_1 = require("../lib/util/console-formatters");
const ONE_DAY_IN_SECONDS = 1 * 24 * 60 * 60;
const exec = util_1.promisify(child_process_1.exec);
exports.DISPLAY_VERSION = `${versionNumber()} (build ${commit()})`;
function versionNumber() {
    return require('../package.json').version.replace(/\+[0-9a-f]+$/, '');
}
exports.versionNumber = versionNumber;
function commit() {
    return require('../build-info.json').commit;
}
class VersionCheckTTL {
    constructor(file, ttlSecs) {
        this.file = file || VersionCheckTTL.timestampFilePath();
        try {
            fs.mkdirsSync(path.dirname(this.file));
            fs.accessSync(path.dirname(this.file), fs.constants.W_OK);
        }
        catch (_a) {
            throw new Error(`Directory (${path.dirname(this.file)}) is not writable.`);
        }
        this.ttlSecs = ttlSecs || ONE_DAY_IN_SECONDS;
    }
    static timestampFilePath() {
        // Get the home directory from the OS, first. Fallback to $HOME.
        const homedir = os.userInfo().homedir || os.homedir();
        if (!homedir || !homedir.trim()) {
            throw new Error('Cannot determine home directory');
        }
        // Using the same path from account-cache.ts
        return path.join(homedir, '.cdk', 'cache', 'repo-version-ttl');
    }
    async hasExpired() {
        try {
            const lastCheckTime = (await fs.stat(this.file)).mtimeMs;
            const today = new Date().getTime();
            if ((today - lastCheckTime) / 1000 > this.ttlSecs) { // convert ms to sec
                return true;
            }
            return false;
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return true;
            }
            else {
                throw err;
            }
        }
    }
    async update(latestVersion) {
        if (!latestVersion) {
            latestVersion = '';
        }
        await fs.writeFile(this.file, latestVersion);
    }
}
exports.VersionCheckTTL = VersionCheckTTL;
// Export for unit testing only.
// Don't use directly, use displayVersionMessage() instead.
async function latestVersionIfHigher(currentVersion, cacheFile) {
    if (!(await cacheFile.hasExpired())) {
        return null;
    }
    const { stdout, stderr } = await exec(`npm view aws-cdk version`);
    if (stderr && stderr.trim().length > 0) {
        logging_1.debug(`The 'npm view' command generated an error stream with content [${stderr.trim()}]`);
    }
    const latestVersion = stdout.trim();
    if (!semver.valid(latestVersion)) {
        throw new Error(`npm returned an invalid semver ${latestVersion}`);
    }
    const isNewer = semver.gt(latestVersion, currentVersion);
    await cacheFile.update(latestVersion);
    if (isNewer) {
        return latestVersion;
    }
    else {
        return null;
    }
}
exports.latestVersionIfHigher = latestVersionIfHigher;
async function displayVersionMessage() {
    if (!process.stdout.isTTY) {
        return;
    }
    try {
        const versionCheckCache = new VersionCheckTTL();
        const laterVersion = await latestVersionIfHigher(versionNumber(), versionCheckCache);
        if (laterVersion) {
            const bannerMsg = console_formatters_1.formatAsBanner([
                `Newer version of CDK is available [${colors.green(laterVersion)}]`,
                `Upgrade recommended`,
            ]);
            bannerMsg.forEach((e) => logging_1.print(e));
        }
    }
    catch (err) {
        logging_1.debug(`Could not run version check - ${err.message}`);
    }
}
exports.displayVersionMessage = displayVersionMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpREFBOEM7QUFDOUMsc0NBQXVDO0FBQ3ZDLCtCQUFnQztBQUNoQyx5QkFBMEI7QUFDMUIsNkJBQThCO0FBQzlCLGlDQUFrQztBQUNsQywrQkFBaUM7QUFDakMsNENBQThDO0FBQzlDLHVFQUFnRTtBQUVoRSxNQUFNLGtCQUFrQixHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUU1QyxNQUFNLElBQUksR0FBRyxnQkFBUyxDQUFDLG9CQUFLLENBQUMsQ0FBQztBQUVqQixRQUFBLGVBQWUsR0FBRyxHQUFHLGFBQWEsRUFBRSxXQUFXLE1BQU0sRUFBRSxHQUFHLENBQUM7QUFFeEUsU0FBZ0IsYUFBYTtJQUMzQixPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3hFLENBQUM7QUFGRCxzQ0FFQztBQUVELFNBQVMsTUFBTTtJQUNiLE9BQU8sT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsTUFBTSxDQUFDO0FBQzlDLENBQUM7QUFFRCxNQUFhLGVBQWU7SUFnQjFCLFlBQVksSUFBYSxFQUFFLE9BQWdCO1FBQ3pDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLGVBQWUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hELElBQUk7WUFDRixFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDdkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNEO1FBQUMsV0FBTTtZQUNO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SCxDQUFDO0FBckJELHNEQXFCQztBQUVNLEtBQUssVUFBVSxxQkFBcUI7SUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ3pCLE9BQU87S0FDUjtJQUVELElBQUk7UUFDRixNQUFNLGlCQUFpQixHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7UUFDaEQsTUFBTSxZQUFZLEdBQUcsTUFBTSxxQkFBcUIsQ0FBQyxhQUFhLEVBQUUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3JGLElBQUksWUFBWSxFQUFFO1lBQ2hCLE1BQU0sU0FBUyxHQUFHLG1DQUFjLENBQUM7Z0JBQy9CLHNDQUFzQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQXNCLENBQUMsR0FBRztnQkFDN0UscUJBQXFCO2FBQ3RCLENBQUMsQ0FBQztZQUNILFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGVBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO0tBQ0Y7SUFBQyxPQUFPLEdBQUcsRUFBRTtRQUNaLGVBQUssQ0FBQyxpQ0FBaUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDdkQ7QUFDSCxDQUFDO0FBbEJELHNEQWtCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMgYXMgX2V4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmltcG9ydCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZm9ybWF0QXNCYW5uZXIgfSBmcm9tICcuLi9saWIvdXRpbC9jb25zb2xlLWZvcm1hdHRlcnMnO1xuXG5jb25zdCBPTkVfREFZX0lOX1NFQ09ORFMgPSAxICogMjQgKiA2MCAqIDYwO1xuXG5jb25zdCBleGVjID0gcHJvbWlzaWZ5KF9leGVjKTtcblxuZXhwb3J0IGNvbnN0IERJU1BMQVlfVkVSU0lPTiA9IGAke3ZlcnNpb25OdW1iZXIoKX0gKGJ1aWxkICR7Y29tbWl0KCl9KWA7XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uTnVtYmVyKCk6IHN0cmluZyB7XG4gIHJldHVybiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLnJlcGxhY2UoL1xcK1swLTlhLWZdKyQvLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdCgpOiBzdHJpbmcge1xuICByZXR1cm4gcmVxdWlyZSgnLi4vYnVpbGQtaW5mby5qc29uJykuY29tbWl0O1xufVxuXG5leHBvcnQgY2xhc3MgVmVyc2lvbkNoZWNrVFRMIHtcbiAgcHVibGljIHN0YXRpYyB0aW1lc3RhbXBGaWxlUGF0aCgpOiBzdHJpbmcge1xuICAgIC8vIEdldCB0aGUgaG9tZSBkaXJlY3RvcnkgZnJvbSB0aGUgT1MsIGZpcnN0LiBGYWxsYmFjayB0byAkSE9NRS5cbiAgICBjb25zdCBob21lZGlyID0gb3MudXNlckluZm8oKS5ob21lZGlyIHx8IG9zLmhvbWVkaXIoKTtcbiAgICBpZiAoIWhvbWVkaXIgfHwgIWhvbWVkaXIudHJpbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlcm1pbmUgaG9tZSBkaXJlY3RvcnknKTtcbiAgICB9XG4gICAgLy8gVXNpbmcgdGhlIHNhbWUgcGF0aCBmcm9tIGFjY291bnQtY2FjaGUudHNcbiAgICByZXR1cm4gcGF0aC5qb2luKGhvbWVkaXIsICcuY2RrJywgJ2NhY2hlJywgJ3JlcG8tdmVyc2lvbi10dGwnKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZTogc3RyaW5nO1xuXG4gIC8vIEZpbGUgbW9kaWZ5IHRpbWVzIGFyZSBhY2N1cmF0ZSBvbmx5IHRvIHRoZSBzZWNvbmRcbiAgcHJpdmF0ZSByZWFkb25seSB0dGxTZWNzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZmlsZT86IHN0cmluZywgdHRsU2Vjcz86IG51bWJlcikge1xuICAgIHRoaXMuZmlsZSA9IGZpbGUgfHwgVmVyc2lvbkNoZWNrVFRMLnRpbWVzdGFtcEZpbGVQYXRoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyc1N5bmMocGF0aC5kaXJuYW1lKHRoaXMuZmlsZSkpO1xuICAgICAgZnMuYWNjZXNzU3luYyhwYXRoLmRpcm5hbWUodGhpcy5maWxlKSwgZnMuY29uc3RhbnRzLldfT0spO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXJlY3RvcnkgKCR7cGF0aC5kaXJuYW1lKHRoaXMuZmlsZSl9KSBpcyBub3Qgd3JpdGFibGUuYCk7XG4gICAgfVxuICAgIHRoaXMudHRsU2VjcyA9IHR0bFNlY3MgfHwgT05FX0RBWV9JTl9TRUNPTkRTO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc0V4cGlyZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxhc3RDaGVja1RpbWUgPSAoYXdhaXQgZnMuc3RhdCh0aGlzLmZpbGUpKS5tdGltZU1zO1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgaWYgKCh0b2RheSAtIGxhc3RDaGVja1RpbWUpIC8gMTAwMCA+IHRoaXMudHRsU2VjcykgeyAvLyBjb252ZXJ0IG1zIHRvIHNlY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwZGF0ZShsYXRlc3RWZXJzaW9uPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFsYXRlc3RWZXJzaW9uKSB7XG4gICAgICBsYXRlc3RWZXJzaW9uID0gJyc7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0aGlzLmZpbGUsIGxhdGVzdFZlcnNpb24pO1xuICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgdW5pdCB0ZXN0aW5nIG9ubHkuXG4vLyBEb24ndCB1c2UgZGlyZWN0bHksIHVzZSBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKSBpbnN0ZWFkLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxhdGVzdFZlcnNpb25JZkhpZ2hlcihjdXJyZW50VmVyc2lvbjogc3RyaW5nLCBjYWNoZUZpbGU6IFZlcnNpb25DaGVja1RUTCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcbiAgaWYgKCEoYXdhaXQgY2FjaGVGaWxlLmhhc0V4cGlyZWQoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWMoYG5wbSB2aWV3IGF3cy1jZGsgdmVyc2lvbmApO1xuICBpZiAoc3RkZXJyICYmIHN0ZGVyci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgIGRlYnVnKGBUaGUgJ25wbSB2aWV3JyBjb21tYW5kIGdlbmVyYXRlZCBhbiBlcnJvciBzdHJlYW0gd2l0aCBjb250ZW50IFske3N0ZGVyci50cmltKCl9XWApO1xuICB9XG4gIGNvbnN0IGxhdGVzdFZlcnNpb24gPSBzdGRvdXQudHJpbSgpO1xuICBpZiAoIXNlbXZlci52YWxpZChsYXRlc3RWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbnBtIHJldHVybmVkIGFuIGludmFsaWQgc2VtdmVyICR7bGF0ZXN0VmVyc2lvbn1gKTtcbiAgfVxuICBjb25zdCBpc05ld2VyID0gc2VtdmVyLmd0KGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKTtcbiAgYXdhaXQgY2FjaGVGaWxlLnVwZGF0ZShsYXRlc3RWZXJzaW9uKTtcblxuICBpZiAoaXNOZXdlcikge1xuICAgIHJldHVybiBsYXRlc3RWZXJzaW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHZlcnNpb25DaGVja0NhY2hlID0gbmV3IFZlcnNpb25DaGVja1RUTCgpO1xuICAgIGNvbnN0IGxhdGVyVmVyc2lvbiA9IGF3YWl0IGxhdGVzdFZlcnNpb25JZkhpZ2hlcih2ZXJzaW9uTnVtYmVyKCksIHZlcnNpb25DaGVja0NhY2hlKTtcbiAgICBpZiAobGF0ZXJWZXJzaW9uKSB7XG4gICAgICBjb25zdCBiYW5uZXJNc2cgPSBmb3JtYXRBc0Jhbm5lcihbXG4gICAgICAgIGBOZXdlciB2ZXJzaW9uIG9mIENESyBpcyBhdmFpbGFibGUgWyR7Y29sb3JzLmdyZWVuKGxhdGVyVmVyc2lvbiBhcyBzdHJpbmcpfV1gLFxuICAgICAgICBgVXBncmFkZSByZWNvbW1lbmRlZGAsXG4gICAgICBdKTtcbiAgICAgIGJhbm5lck1zZy5mb3JFYWNoKChlKSA9PiBwcmludChlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZyhgQ291bGQgbm90IHJ1biB2ZXJzaW9uIGNoZWNrIC0gJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufVxuIl19