"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const api_1 = require("../api");
const logging_1 = require("../logging");
class VpcNetworkContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const account = args.account;
        const region = args.region;
        const ec2 = await this.aws.ec2(account, region, api_1.Mode.ForReading);
        const vpcId = await this.findVpc(ec2, args);
        return await this.readVpcProps(ec2, vpcId, args);
    }
    async findVpc(ec2, args) {
        // Build request filter (map { Name -> Value } to list of [{ Name, Values }])
        const filters = Object.entries(args.filter).map(([tag, value]) => ({ Name: tag, Values: [value] }));
        logging_1.debug(`Listing VPCs in ${args.account}:${args.region}`);
        const response = await ec2.describeVpcs({ Filters: filters }).promise();
        const vpcs = response.Vpcs || [];
        if (vpcs.length === 0) {
            throw new Error(`Could not find any VPCs matching ${JSON.stringify(args)}`);
        }
        if (vpcs.length > 1) {
            throw new Error(`Found ${vpcs.length} VPCs matching ${JSON.stringify(args)}; please narrow the search criteria`);
        }
        return vpcs[0].VpcId;
    }
    async readVpcProps(ec2, vpcId, args) {
        logging_1.debug(`Describing VPC ${vpcId}`);
        const filters = { Filters: [{ Name: 'vpc-id', Values: [vpcId] }] };
        const subnetsResponse = await ec2.describeSubnets(filters).promise();
        const listedSubnets = subnetsResponse.Subnets || [];
        const routeTablesResponse = await ec2.describeRouteTables(filters).promise();
        const routeTables = new RouteTables(routeTablesResponse.RouteTables || []);
        // Now comes our job to separate these subnets out into AZs and subnet groups (Public, Private, Isolated)
        // We have the following attributes to go on:
        // - Type tag, we tag subnets with their type. In absence of this tag, we
        //   fall back to MapPublicIpOnLaunch => must be a Public subnet, anything
        //   else is considered Priate.
        // - Name tag, we tag subnets with their subnet group name. In absence of this tag,
        //   we use the type as the name.
        const azs = Array.from(new Set(listedSubnets.map(s => s.AvailabilityZone)));
        azs.sort();
        const subnets = listedSubnets.map(subnet => {
            let type = getTag('aws-cdk:subnet-type', subnet.Tags);
            if (type === undefined && subnet.MapPublicIpOnLaunch) {
                type = SubnetType.Public;
            }
            if (type === undefined && routeTables.hasRouteToIgw(subnet.SubnetId)) {
                type = SubnetType.Public;
            }
            if (type === undefined) {
                type = SubnetType.Private;
            }
            if (!isValidSubnetType(type)) {
                // tslint:disable-next-line: max-line-length
                throw new Error(`Subnet ${subnet.SubnetArn} has invalid subnet type ${type} (must be ${SubnetType.Public}, ${SubnetType.Private} or ${SubnetType.Isolated})`);
            }
            const name = getTag(args.subnetGroupNameTag || 'aws-cdk:subnet-name', subnet.Tags) || type;
            const routeTableId = routeTables.routeTableIdForSubnetId(subnet.SubnetId);
            if (!routeTableId) {
                throw new Error(`Subnet ${subnet.SubnetArn} does not have an associated route table (and there is no "main" table)`);
            }
            return {
                az: subnet.AvailabilityZone,
                type,
                name,
                subnetId: subnet.SubnetId,
                routeTableId,
            };
        });
        let grouped;
        let assymetricSubnetGroups;
        if (args.returnAsymmetricSubnets) {
            grouped = { azs: [], groups: [] };
            assymetricSubnetGroups = groupAsymmetricSubnets(subnets);
        }
        else {
            grouped = groupSubnets(subnets);
            assymetricSubnetGroups = undefined;
        }
        // Find attached+available VPN gateway for this VPC
        const vpnGatewayResponse = await ec2.describeVpnGateways({
            Filters: [
                {
                    Name: 'attachment.vpc-id',
                    Values: [vpcId]
                },
                {
                    Name: 'attachment.state',
                    Values: ['attached']
                },
                {
                    Name: 'state',
                    Values: ['available']
                }
            ]
        }).promise();
        const vpnGatewayId = vpnGatewayResponse.VpnGateways && vpnGatewayResponse.VpnGateways.length === 1
            ? vpnGatewayResponse.VpnGateways[0].VpnGatewayId
            : undefined;
        return {
            vpcId,
            availabilityZones: grouped.azs,
            isolatedSubnetIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.subnetId))),
            isolatedSubnetNames: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.name ? [group.name] : [])),
            isolatedSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.routeTableId))),
            privateSubnetIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.subnetId))),
            privateSubnetNames: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.name ? [group.name] : [])),
            privateSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.routeTableId))),
            publicSubnetIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.subnetId))),
            publicSubnetNames: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.name ? [group.name] : [])),
            publicSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.routeTableId))),
            vpnGatewayId,
            subnetGroups: assymetricSubnetGroups,
        };
    }
}
exports.VpcNetworkContextProviderPlugin = VpcNetworkContextProviderPlugin;
class RouteTables {
    constructor(tables) {
        this.tables = tables;
        this.mainRouteTable = this.tables.find(table => !!table.Associations && table.Associations.some(assoc => !!assoc.Main));
    }
    routeTableIdForSubnetId(subnetId) {
        const table = this.tableForSubnet(subnetId);
        return (table && table.RouteTableId) || (this.mainRouteTable && this.mainRouteTable.RouteTableId);
    }
    /**
     * Whether the given subnet has a route to an IGW
     */
    hasRouteToIgw(subnetId) {
        const table = this.tableForSubnet(subnetId);
        return !!table && !!table.Routes && table.Routes.some(route => !!route.GatewayId && route.GatewayId.startsWith('igw-'));
    }
    tableForSubnet(subnetId) {
        return this.tables.find(table => !!table.Associations && table.Associations.some(assoc => assoc.SubnetId === subnetId));
    }
}
/**
 * Return the value of a tag from a set of tags
 */
function getTag(name, tags) {
    for (const tag of tags || []) {
        if (tag.Key === name) {
            return tag.Value;
        }
    }
    return undefined;
}
/**
 * Group subnets of the same type together, and order by AZ
 */
function groupSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    const groups = Object.values(grouping).map(sns => {
        sns.sort((a, b) => a.az.localeCompare(b.az));
        return {
            type: sns[0].type,
            name: sns[0].name,
            subnets: sns,
        };
    });
    const azs = groups[0].subnets.map(s => s.az);
    for (const group of groups) {
        const groupAZs = group.subnets.map(s => s.az);
        if (!arraysEqual(groupAZs, azs)) {
            throw new Error(`Not all subnets in VPC have the same AZs: ${groupAZs} vs ${azs}`);
        }
    }
    return { azs, groups };
}
function groupAsymmetricSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    return Object.values(grouping).map(subnetArray => {
        subnetArray.sort((subnet1, subnet2) => subnet1.az.localeCompare(subnet2.az));
        return {
            name: subnetArray[0].name,
            type: subnetTypeToVpcSubnetType(subnetArray[0].type),
            subnets: subnetArray.map(subnet => ({
                subnetId: subnet.subnetId,
                availabilityZone: subnet.az,
                routeTableId: subnet.routeTableId,
            })),
        };
    });
}
function subnetTypeToVpcSubnetType(type) {
    switch (type) {
        case SubnetType.Isolated: return cxapi.VpcSubnetGroupType.ISOLATED;
        case SubnetType.Private: return cxapi.VpcSubnetGroupType.PRIVATE;
        case SubnetType.Public: return cxapi.VpcSubnetGroupType.PUBLIC;
    }
}
var SubnetType;
(function (SubnetType) {
    SubnetType["Public"] = "Public";
    SubnetType["Private"] = "Private";
    SubnetType["Isolated"] = "Isolated";
})(SubnetType || (SubnetType = {}));
function isValidSubnetType(val) {
    return val === SubnetType.Public
        || val === SubnetType.Private
        || val === SubnetType.Isolated;
}
function arraysEqual(as, bs) {
    if (as.length !== bs.length) {
        return false;
    }
    for (let i = 0; i < as.length; i++) {
        if (as[i] !== bs[i]) {
            return false;
        }
    }
    return true;
}
function findGroups(type, groups) {
    return groups.groups.filter(g => g.type === type);
}
function flatMap(xs, fn) {
    const ret = new Array();
    for (const x of xs) {
        ret.push(...fn(x));
    }
    return ret;
}
function collapse(xs) {
    if (xs.length > 0) {
        return xs;
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnBjcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZwY3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBMEM7QUFFMUMsZ0NBQW9DO0FBQ3BDLHdDQUFtQztBQUduQyxNQUFhLCtCQUErQjtJQUUxQyxZQUE2QixHQUFTO1FBQVQsUUFBRyxHQUFILEdBQUcsQ0FBTTtJQUN0QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUEyQjtRQUMvQyxNQUFNLE9BQU8sR0FBVyxJQUFJLENBQUMsT0FBUSxDQUFDO1FBQ3RDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxNQUFPLENBQUM7UUFFcEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVqRSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTVDLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBWSxFQUFFLElBQTJCO1FBQzdELDZFQUE2RTtRQUM3RSxNQUFNLE9BQU8sR0FBcUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXRILGVBQUssQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUN4RCxN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Q0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNsQixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDcEI7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBSSxFQUFPO0lBQzFCLElBQUksRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFBRSxPQUFPLEVBQUUsQ0FBQztLQUFFO0lBQ2pDLE9BQU8sU0FBUyxDQUFDO0FBRW5CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCBBV1MgPSByZXF1aXJlKCdhd3Mtc2RrJyk7XG5pbXBvcnQgeyBJU0RLLCBNb2RlIH0gZnJvbSAnLi4vYXBpJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuL3Byb3ZpZGVyJztcblxuZXhwb3J0IGNsYXNzIFZwY05ldHdvcmtDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBJU0RLKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoYXJnczogY3hhcGkuVnBjQ29udGV4dFF1ZXJ5KSB7XG4gICAgY29uc3QgYWNjb3VudDogc3RyaW5nID0gYXJncy5hY2NvdW50ITtcbiAgICBjb25zdCByZWdpb246IHN0cmluZyA9IGFyZ3MucmVnaW9uITtcblxuICAgIGNvbnN0IGVjMiA9IGF3YWl0IHRoaXMuYXdzLmVjMihhY2NvdW50LCByZWdpb24sIE1vZGUuRm9yUmVhZGluZyk7XG5cbiAgICBjb25zdCB2cGNJZCA9IGF3YWl0IHRoaXMuZmluZFZwYyhlYzIsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVhZFZwY1Byb3BzKGVjMiwgdnBjSWQsIGFyZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmaW5kVnBjKGVjMjogQVdTLkVDMiwgYXJnczogY3hhcGkuVnBjQ29udGV4dFF1ZXJ5KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBCdWlsZCByZXF1ZXN0IGZpbHRlciAobWFwIHsgTmFtZSAtPiBWYWx1ZSB9IHRvIGxpc3Qgb2YgW3sgTmFtZSwgVmFsdWVzIH1dKVxuICAgIGNvbnN0IGZpbHRlcnM6IEFXUy5FQzIuRmlsdGVyW10gPSBPYmplY3QuZW50cmllcyhhcmdzLmZpbHRlcikubWFwKChbdGFnLCB2YWx1ZV0pID0+ICh7IE5hbWU6IHRhZywgVmFsdWVzOiBbdmFsdWVdIH0pKTtcblxuICAgIGRlYnVnKGBMaXN0aW5nIFZQQ3MgaW4gJHthcmdzLmFjY291bnR9OiR7YXJncy5yZWdpb259YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlYzIuZGVzY3JpYmVWcGNzKHsgRmlsdGVyczogZmlsdGVycyB9KS5wcm9taXNlKCk7XG5cbiAgICBjb25zdCB2cGNzID0gcmVzcG9uc2UuVnBjcyB8fCBbXTtcbiAgICBpZiAodnBjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IFZQQ3MgbWF0Y2hpbmcgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgICB9XG4gICAgaWYgKHZwY3MubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAke3ZwY3MubGVuZ3RofSBWUENzIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9OyBwbGVhc2UgbmFycm93IHRoZSBzZWFyY2ggY3JpdGVyaWFgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdnBjc1swXS5WcGNJZCE7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlYWRWcGNQcm9wcyhlYzI6IEFXUy5FQzIsIHZwY0lkOiBzdHJpbmcsIGFyZ3M6IGN4YXBpLlZwY0NvbnRleHRRdWVyeSk6IFByb21pc2U8Y3hhcGkuVnBjQ29udGV4dFJlc3BvbnNlPiB7XG4gICAgZGVidWcoYERlc2NyaWJpbmcgVlBDICR7dnBjSWR9YCk7XG5cbiAgICBjb25zdCBmaWx0ZXJzID0geyBGaWx0ZXJzOiBbeyBOYW1lOiAndnBjLWlkJywgVmFsdWVzOiBbdnBjSWRdIH1dIH07XG5cbiAgICBjb25zdCBzdWJuZXRzUmVzcG9uc2UgPSBhd2FpdCBlYzIuZGVzY3JpYmVTdWJuZXRzKGZpbHRlcnMpLnByb21pc2UoKTtcbiAgICBjb25zdCBsaXN0ZWRTdWJuZXRzID0gc3VibmV0c1Jlc3BvbnNlLlN1Ym5ldHMgfHwgW107XG5cbiAgICBjb25zdCByb3V0ZVRhYmxlc1Jlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlUm91dGVUYWJsZXMoZmlsdGVycykucHJvbWlzZSgpO1xuICAgIGNvbnN0IHJvdXRlVGFibGVzID0gbmV3IFJvdXRlVGFibGVzKHJvdXRlVGFibGVzUmVzcG9uc2UuUm91dGVUYWJsZXMgfHwgW10pO1xuXG4gICAgLy8gTm93IGNvbWVzIG91ciBqb2IgdG8gc2VwYXJhdGUgdGhlc2Ugc3VibmV0cyBvdXQgaW50byBBWnMgYW5kIHN1Ym5ldCBncm91cHMgKFB1YmxpYywgUHJpdmF0ZSwgSXNvbGF0ZWQpXG4gICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMgdG8gZ28gb246XG4gICAgLy8gLSBUeXBlIHRhZywgd2UgdGFnIHN1Ym5ldHMgd2l0aCB0aGVpciB0eXBlLiBJbiBhYnNlbmNlIG9mIHRoaXMgdGFnLCB3ZVxuICAgIC8vICAgZmFsbCBiYWNrIHRvIE1hcFB1YmxpY0lwT25MYXVuY2ggPT4gbXVzdCBiZSBhIFB1YmxpYyBzdWJuZXQsIGFueXRoaW5nXG4gICAgLy8gICBlbHNlIGlzIGNvbnNpZGVyZWQgUHJpYXRlLlxuICAgIC8vIC0gTmFtZSB0YWcsIHdlIHRhZyBzdWJuZXRzIHdpdGggdGhlaXIgc3VibmV0IGdyb3VwIG5hbWUuIEluIGFic2VuY2Ugb2YgdGhpcyB0YWcsXG4gICAgLy8gICB3ZSB1c2UgdGhlIHR5cGUgYXMgdGhlIG5hbWUuXG5cbiAgICBjb25zdCBhenMgPSBBcnJheS5mcm9tKG5ldyBTZXQ8c3RyaW5nPihsaXN0ZWRTdWJuZXRzLm1hcChzID0+IHMuQXZhaWxhYmlsaXR5Wm9uZSEpKSk7XG4gICAgYXpzLnNvcnQoKTtcblxuICAgIGNvbnN0IHN1Ym5ldHM6IFN1Ym5ldFtdID0gbGlzdGVkU3VibmV0cy5tYXAoc3VibmV0ID0+IHtcbiAgICAgIGxldCB0eXBlID0gZ2V0VGFnKCdhd3MtY2RrOnN1Ym5ldC10eXBlJywgc3VibmV0LlRhZ3MpO1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBzdWJuZXQuTWFwUHVibGljSXBPbkxhdW5jaCkgeyB0eXBlID0gU3VibmV0VHlwZS5QdWJsaWM7IH1cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgcm91dGVUYWJsZXMuaGFzUm91dGVUb0lndyhzdWJuZXQuU3VibmV0SWQpKSB7IHR5cGUgPSBTdWJuZXRUeXBlLlB1YmxpYzsgfVxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gU3VibmV0VHlwZS5Qcml2YXRlOyB9XG5cbiAgICAgIGlmICghaXNWYWxpZFN1Ym5ldFR5cGUodHlwZSkpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJuZXQgJHtzdWJuZXQuU3VibmV0QXJufSBoYXMgaW52YWxpZCBzdWJuZXQgdHlwZSAke3R5cGV9IChtdXN0IGJlICR7U3VibmV0VHlwZS5QdWJsaWN9LCAke1N1Ym5ldFR5cGUuUHJpdmF0ZX0gb3IgJHtTdWJuZXRUeXBlLklzb2xhdGVkfSlgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9IGdldFRhZyhhcmdzLnN1Ym5ldEdyb3VwTmFtZVRhZyB8fCAnYXdzLWNkazpzdWJuZXQtbmFtZScsIHN1Ym5ldC5UYWdzKSB8fCB0eXBlO1xuICAgICAgY29uc3Qgcm91dGVUYWJsZUlkID0gcm91dGVUYWJsZXMucm91dGVUYWJsZUlkRm9yU3VibmV0SWQoc3VibmV0LlN1Ym5ldElkKTtcblxuICAgICAgaWYgKCFyb3V0ZVRhYmxlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJuZXQgJHtzdWJuZXQuU3VibmV0QXJufSBkb2VzIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgcm91dGUgdGFibGUgKGFuZCB0aGVyZSBpcyBubyBcIm1haW5cIiB0YWJsZSlgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXo6IHN1Ym5ldC5BdmFpbGFiaWxpdHlab25lISxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3VibmV0SWQ6IHN1Ym5ldC5TdWJuZXRJZCEsXG4gICAgICAgIHJvdXRlVGFibGVJZCxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBsZXQgZ3JvdXBlZDogU3VibmV0R3JvdXBzO1xuICAgIGxldCBhc3N5bWV0cmljU3VibmV0R3JvdXBzOiBjeGFwaS5WcGNTdWJuZXRHcm91cFtdIHwgdW5kZWZpbmVkO1xuICAgIGlmIChhcmdzLnJldHVybkFzeW1tZXRyaWNTdWJuZXRzKSB7XG4gICAgICBncm91cGVkID0geyBhenM6IFtdLCBncm91cHM6IFtdIH07XG4gICAgICBhc3N5bWV0cmljU3VibmV0R3JvdXBzID0gZ3JvdXBBc3ltbWV0cmljU3VibmV0cyhzdWJuZXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBlZCA9IGdyb3VwU3VibmV0cyhzdWJuZXRzKTtcbiAgICAgIGFzc3ltZXRyaWNTdWJuZXRHcm91cHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gRmluZCBhdHRhY2hlZCthdmFpbGFibGUgVlBOIGdhdGV3YXkgZm9yIHRoaXMgVlBDXG4gICAgY29uc3QgdnBuR2F0ZXdheVJlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlVnBuR2F0ZXdheXMoe1xuICAgICAgRmlsdGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgTmFtZTogJ2F0dGFjaG1lbnQudnBjLWlkJyxcbiAgICAgICAgICBWYWx1ZXM6IFt2cGNJZF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIE5hbWU6ICdhdHRhY2htZW50LnN0YXRlJyxcbiAgICAgICAgICBWYWx1ZXM6IFsnYXR0YWNoZWQnXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgTmFtZTogJ3N0YXRlJyxcbiAgICAgICAgICBWYWx1ZXM6IFsnYXZhaWxhYmxlJ11cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLnByb21pc2UoKTtcbiAgICBjb25zdCB2cG5HYXRld2F5SWQgPSB2cG5HYXRld2F5UmVzcG9uc2UuVnBuR2F0ZXdheXMgJiYgdnBuR2F0ZXdheVJlc3BvbnNlLlZwbkdhdGV3YXlzLmxlbmd0aCA9PT0gMVxuICAgICAgPyB2cG5HYXRld2F5UmVzcG9uc2UuVnBuR2F0ZXdheXNbMF0uVnBuR2F0ZXdheUlkXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7XG4gICAgICB2cGNJZCxcbiAgICAgIGF2YWlsYWJpbGl0eVpvbmVzOiBncm91cGVkLmF6cyxcbiAgICAgIGlzb2xhdGVkU3VibmV0SWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5Jc29sYXRlZCwgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLnN1Ym5ldHMubWFwKHMgPT4gcy5zdWJuZXRJZCkpKSxcbiAgICAgIGlzb2xhdGVkU3VibmV0TmFtZXM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLklzb2xhdGVkLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAubmFtZSA/IFtncm91cC5uYW1lXSA6IFtdKSksXG4gICAgICBpc29sYXRlZFN1Ym5ldFJvdXRlVGFibGVJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLklzb2xhdGVkLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnJvdXRlVGFibGVJZCkpKSxcbiAgICAgIHByaXZhdGVTdWJuZXRJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLlByaXZhdGUsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMuc3VibmV0SWQpKSksXG4gICAgICBwcml2YXRlU3VibmV0TmFtZXM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLlByaXZhdGUsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5uYW1lID8gW2dyb3VwLm5hbWVdIDogW10pKSxcbiAgICAgIHByaXZhdGVTdWJuZXRSb3V0ZVRhYmxlSWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5Qcml2YXRlLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnJvdXRlVGFibGVJZCkpKSxcbiAgICAgIHB1YmxpY1N1Ym5ldElkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHVibGljLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnN1Ym5ldElkKSkpLFxuICAgICAgcHVibGljU3VibmV0TmFtZXM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLlB1YmxpYywgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLm5hbWUgPyBbZ3JvdXAubmFtZV0gOiBbXSkpLFxuICAgICAgcHVibGljU3VibmV0Um91dGVUYWJsZUlkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHVibGljLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnJvdXRlVGFibGVJZCkpKSxcbiAgICAgIHZwbkdhdGV3YXlJZCxcbiAgICAgIHN1Ym5ldEdyb3VwczogYXNzeW1ldHJpY1N1Ym5ldEdyb3VwcyxcbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIFJvdXRlVGFibGVzIHtcbiAgcHVibGljIHJlYWRvbmx5IG1haW5Sb3V0ZVRhYmxlPzogQVdTLkVDMi5Sb3V0ZVRhYmxlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdGFibGVzOiBBV1MuRUMyLlJvdXRlVGFibGVbXSkge1xuICAgIHRoaXMubWFpblJvdXRlVGFibGUgPSB0aGlzLnRhYmxlcy5maW5kKHRhYmxlID0+ICEhdGFibGUuQXNzb2NpYXRpb25zICYmIHRhYmxlLkFzc29jaWF0aW9ucy5zb21lKGFzc29jID0+ICEhYXNzb2MuTWFpbikpO1xuICB9XG5cbiAgcHVibGljIHJvdXRlVGFibGVJZEZvclN1Ym5ldElkKHN1Ym5ldElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy50YWJsZUZvclN1Ym5ldChzdWJuZXRJZCk7XG4gICAgcmV0dXJuICh0YWJsZSAmJiB0YWJsZS5Sb3V0ZVRhYmxlSWQpIHx8ICh0aGlzLm1haW5Sb3V0ZVRhYmxlICYmIHRoaXMubWFpblJvdXRlVGFibGUuUm91dGVUYWJsZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBzdWJuZXQgaGFzIGEgcm91dGUgdG8gYW4gSUdXXG4gICAqL1xuICBwdWJsaWMgaGFzUm91dGVUb0lndyhzdWJuZXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlRm9yU3VibmV0KHN1Ym5ldElkKTtcblxuICAgIHJldHVybiAhIXRhYmxlICYmICEhdGFibGUuUm91dGVzICYmIHRhYmxlLlJvdXRlcy5zb21lKHJvdXRlID0+ICEhcm91dGUuR2F0ZXdheUlkICYmIHJvdXRlLkdhdGV3YXlJZC5zdGFydHNXaXRoKCdpZ3ctJykpO1xuICB9XG5cbiAgcHVibGljIHRhYmxlRm9yU3VibmV0KHN1Ym5ldElkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZXMuZmluZCh0YWJsZSA9PiAhIXRhYmxlLkFzc29jaWF0aW9ucyAmJiB0YWJsZS5Bc3NvY2lhdGlvbnMuc29tZShhc3NvYyA9PiBhc3NvYy5TdWJuZXRJZCA9PT0gc3VibmV0SWQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgYSB0YWcgZnJvbSBhIHNldCBvZiB0YWdzXG4gKi9cbmZ1bmN0aW9uIGdldFRhZyhuYW1lOiBzdHJpbmcsIHRhZ3M/OiBBV1MuRUMyLlRhZ1tdKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB0YWcgb2YgdGFncyB8fCBbXSkge1xuICAgIGlmICh0YWcuS2V5ID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gdGFnLlZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdyb3VwIHN1Ym5ldHMgb2YgdGhlIHNhbWUgdHlwZSB0b2dldGhlciwgYW5kIG9yZGVyIGJ5IEFaXG4gKi9cbmZ1bmN0aW9uIGdyb3VwU3VibmV0cyhzdWJuZXRzOiBTdWJuZXRbXSk6IFN1Ym5ldEdyb3VwcyB7XG4gIGNvbnN0IGdyb3VwaW5nOiB7W2tleTogc3RyaW5nXTogU3VibmV0W119ID0ge307XG4gIGZvciAoY29uc3Qgc3VibmV0IG9mIHN1Ym5ldHMpIHtcbiAgICBjb25zdCBrZXkgPSBbc3VibmV0LnR5cGUsIHN1Ym5ldC5uYW1lXS50b1N0cmluZygpO1xuICAgIGlmICghKGtleSBpbiBncm91cGluZykpIHsgZ3JvdXBpbmdba2V5XSA9IFtdOyB9XG4gICAgZ3JvdXBpbmdba2V5XS5wdXNoKHN1Ym5ldCk7XG4gIH1cblxuICBjb25zdCBncm91cHMgPSBPYmplY3QudmFsdWVzKGdyb3VwaW5nKS5tYXAoc25zID0+IHtcbiAgICBzbnMuc29ydCgoYTogU3VibmV0LCBiOiBTdWJuZXQpID0+IGEuYXoubG9jYWxlQ29tcGFyZShiLmF6KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHNuc1swXS50eXBlLFxuICAgICAgbmFtZTogc25zWzBdLm5hbWUsXG4gICAgICBzdWJuZXRzOiBzbnMsXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgYXpzID0gZ3JvdXBzWzBdLnN1Ym5ldHMubWFwKHMgPT4gcy5heik7XG5cbiAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICBjb25zdCBncm91cEFacyA9IGdyb3VwLnN1Ym5ldHMubWFwKHMgPT4gcy5heik7XG4gICAgaWYgKCFhcnJheXNFcXVhbChncm91cEFacywgYXpzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYWxsIHN1Ym5ldHMgaW4gVlBDIGhhdmUgdGhlIHNhbWUgQVpzOiAke2dyb3VwQVpzfSB2cyAke2F6c31gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBhenMsIGdyb3VwcyB9O1xufVxuXG5mdW5jdGlvbiBncm91cEFzeW1tZXRyaWNTdWJuZXRzKHN1Ym5ldHM6IFN1Ym5ldFtdKTogY3hhcGkuVnBjU3VibmV0R3JvdXBbXSB7XG4gIGNvbnN0IGdyb3VwaW5nOiB7IFtrZXk6IHN0cmluZ106IFN1Ym5ldFtdIH0gPSB7fTtcbiAgZm9yIChjb25zdCBzdWJuZXQgb2Ygc3VibmV0cykge1xuICAgIGNvbnN0IGtleSA9IFtzdWJuZXQudHlwZSwgc3VibmV0Lm5hbWVdLnRvU3RyaW5nKCk7XG4gICAgaWYgKCEoa2V5IGluIGdyb3VwaW5nKSkge1xuICAgICAgZ3JvdXBpbmdba2V5XSA9IFtdO1xuICAgIH1cbiAgICBncm91cGluZ1trZXldLnB1c2goc3VibmV0KTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKGdyb3VwaW5nKS5tYXAoc3VibmV0QXJyYXkgPT4ge1xuICAgIHN1Ym5ldEFycmF5LnNvcnQoKHN1Ym5ldDE6IFN1Ym5ldCwgc3VibmV0MjogU3VibmV0KSA9PiBzdWJuZXQxLmF6LmxvY2FsZUNvbXBhcmUoc3VibmV0Mi5heikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHN1Ym5ldEFycmF5WzBdLm5hbWUsXG4gICAgICB0eXBlOiBzdWJuZXRUeXBlVG9WcGNTdWJuZXRUeXBlKHN1Ym5ldEFycmF5WzBdLnR5cGUpLFxuICAgICAgc3VibmV0czogc3VibmV0QXJyYXkubWFwKHN1Ym5ldCA9PiAoe1xuICAgICAgICBzdWJuZXRJZDogc3VibmV0LnN1Ym5ldElkLFxuICAgICAgICBhdmFpbGFiaWxpdHlab25lOiBzdWJuZXQuYXosXG4gICAgICAgIHJvdXRlVGFibGVJZDogc3VibmV0LnJvdXRlVGFibGVJZCxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3VibmV0VHlwZVRvVnBjU3VibmV0VHlwZSh0eXBlOiBTdWJuZXRUeXBlKTogY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTdWJuZXRUeXBlLklzb2xhdGVkOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLklTT0xBVEVEO1xuICAgIGNhc2UgU3VibmV0VHlwZS5Qcml2YXRlOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLlBSSVZBVEU7XG4gICAgY2FzZSBTdWJuZXRUeXBlLlB1YmxpYzogcmV0dXJuIGN4YXBpLlZwY1N1Ym5ldEdyb3VwVHlwZS5QVUJMSUM7XG4gIH1cbn1cblxuZW51bSBTdWJuZXRUeXBlIHtcbiAgUHVibGljID0gJ1B1YmxpYycsXG4gIFByaXZhdGUgPSAnUHJpdmF0ZScsXG4gIElzb2xhdGVkID0gJ0lzb2xhdGVkJ1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkU3VibmV0VHlwZSh2YWw6IHN0cmluZyk6IHZhbCBpcyBTdWJuZXRUeXBlIHtcbiAgcmV0dXJuIHZhbCA9PT0gU3VibmV0VHlwZS5QdWJsaWNcbiAgICB8fCB2YWwgPT09IFN1Ym5ldFR5cGUuUHJpdmF0ZVxuICAgIHx8IHZhbCA9PT0gU3VibmV0VHlwZS5Jc29sYXRlZDtcbn1cblxuaW50ZXJmYWNlIFN1Ym5ldCB7XG4gIGF6OiBzdHJpbmc7XG4gIHR5cGU6IFN1Ym5ldFR5cGU7XG4gIG5hbWU6IHN0cmluZztcbiAgcm91dGVUYWJsZUlkOiBzdHJpbmc7XG4gIHN1Ym5ldElkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTdWJuZXRHcm91cCB7XG4gIHR5cGU6IFN1Ym5ldFR5cGU7XG4gIG5hbWU6IHN0cmluZztcbiAgc3VibmV0czogU3VibmV0W107XG59XG5cbmludGVyZmFjZSBTdWJuZXRHcm91cHMge1xuICBhenM6IHN0cmluZ1tdO1xuICBncm91cHM6IFN1Ym5ldEdyb3VwW107XG59XG5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFzOiBzdHJpbmdbXSwgYnM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gIGlmIChhcy5sZW5ndGggIT09IGJzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFzW2ldICE9PSBic1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5kR3JvdXBzKHR5cGU6IFN1Ym5ldFR5cGUsIGdyb3VwczogU3VibmV0R3JvdXBzKTogU3VibmV0R3JvdXBbXSB7XG4gIHJldHVybiBncm91cHMuZ3JvdXBzLmZpbHRlcihnID0+IGcudHlwZSA9PT0gdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXA8VCwgVT4oeHM6IFRbXSwgZm46ICh4OiBUKSA9PiBVW10pOiBVW10ge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8VT4oKTtcbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgcmV0LnB1c2goLi4uZm4oeCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlPFQ+KHhzOiBUW10pOiBUW10gfCB1bmRlZmluZWQge1xuICBpZiAoeHMubGVuZ3RoID4gMCkgeyByZXR1cm4geHM7IH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcblxufVxuIl19