"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
// ----------------------------------------------------------------------
//
//   READ THIS FIRST WHEN CHANGING THIS FILE
//
// ----------------------------------------------------------------------
//
// You need (and only need) to bump the CLOUD_ASSEMBLY_VERSION if the cloud
// assembly needs new features from the CDK CLI. Examples: new fields, new
// behavior, new artifact types.
//
// If that happens, you set the CLOUD_ASSEMBLY_VERSION to the *next* (not the
// current!) CDK version that will be released. This is done to produce
// useful error messages.
//
// When you do this, you will force users of a new library to upgrade the CLI
// (good), but UNLESS YOU ALSO IMPLEMENT 'upgradeAssemblyManifest' you will also
// force people who have installed a newer CLI to upgrade their libraries (bad!).
// Do that too, unless you have a very good reason not to.
/**
 * Bump this to the library version if and only if the CX protocol changes.
 *
 * We could also have used 1, 2, 3, ... here to indicate protocol versions, but
 * those then still need to be mapped to software versions to be useful. So we
 * might as well use the software version as protocol version and immediately
 * generate a useful error message from this.
 *
 * Note that the versions are not compared in a semver way, they are used as
 * opaque ordered tokens.
 */
exports.CLOUD_ASSEMBLY_VERSION = '1.16.0';
/**
 * Look at the type of response we get and upgrade it to the latest expected version
 */
function verifyManifestVersion(manifetVersion) {
    const frameworkVersion = parseSemver(manifetVersion);
    const toolkitVersion = parseSemver(exports.CLOUD_ASSEMBLY_VERSION);
    // if framework > cli, we require a newer cli version
    if (semver.gt(frameworkVersion, toolkitVersion)) {
        throw new Error(`A newer version of the CDK CLI (>= ${frameworkVersion}) is necessary to interact with this app`);
    }
    // if framework < cli, we require a newer framework version
    if (semver.lt(frameworkVersion, toolkitVersion)) {
        throw new Error(`The CDK CLI you are using requires your app to use CDK modules with version >= ${exports.CLOUD_ASSEMBLY_VERSION}`);
    }
}
exports.verifyManifestVersion = verifyManifestVersion;
/**
 * Upgrade old manifest versions to later manifest version here (if possible).
 *
 * Use this to make the toolkit recognize old assembly versions. This function should
 * add newly required fields with appropriate default values, etc.
 */
function upgradeAssemblyManifest(manifest) {
    if (manifest.version === '0.36.0') {
        // Adding a new artifact type, old version will not have it so painless upgrade.
        manifest = justUpgradeVersion(manifest, '1.10.0');
    }
    if (manifest.version === '1.10.0') {
        // Two changes:
        // * Backwards-compatible changes to the VPC provider
        // * Added AMI context provider: old assemblies won't reference it.
        manifest = justUpgradeVersion(manifest, '1.16.0');
    }
    return manifest;
}
exports.upgradeAssemblyManifest = upgradeAssemblyManifest;
function parseSemver(version) {
    const ver = semver.coerce(version);
    if (!ver) {
        throw new Error(`Could not parse "${version}" as semver`);
    }
    return ver;
}
/**
 * Return a copy of the manifest with just the version field updated
 *
 * Useful if there are protocol changes that are automatically backwards
 * compatible.
 */
function justUpgradeVersion(manifest, version) {
    return Object.assign({}, manifest, { version });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb25pbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBa0M7QUFHbEMseUVBQXlFO0FBQ3pFLEVBQUU7QUFDRiw0Q0FBNEM7QUFDNUMsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSxFQUFFO0FBQ0YsMkVBQTJFO0FBQzNFLDBFQUEwRTtBQUMxRSxnQ0FBZ0M7QUFDaEMsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSx1RUFBdUU7QUFDdkUseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsZ0ZBQWdGO0FBQ2hGLGlGQUFpRjtBQUNqRiwwREFBMEQ7QUFFMUQ7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsc0JBQXNCLEdBQUcsUUFBUSxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsY0FBc0I7SUFDMUQsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDckQsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLDhCQUFzQixDQUFDLENBQUM7SUFFM0QscURBQXFEO0lBQ3JELElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsRUFBRTtRQUMvQyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxnQkFBZ0IsMENBQTBDLENBQUMsQ0FBQztLQUNuSDtJQUVELDJEQUEyRDtJQUMzRCxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDLEVBQUU7UUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRkFBa0YsOEJBQXNCLEVBQUUsQ0FBQyxDQUFDO0tBQzdIO0FBQ0gsQ0FBQztBQWJELHNEQWFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQix1QkFBdUIsQ0FBQyxRQUEwQjtJQUVoRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO1FBQ2pDLGdGQUFnRjtRQUNoRixRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtRQUNqQyxlQUFlO1FBQ2YscURBQXFEO1FBQ3JELG1FQUFtRTtRQUNuRSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQWZELDBEQWVDO0FBRUQsU0FBUyxXQUFXLENBQUMsT0FBZTtJQUNsQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixPQUFPLGFBQWEsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGtCQUFrQixDQUFDLFFBQTBCLEVBQUUsT0FBZTtJQUNyRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDbEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmltcG9ydCB7IEFzc2VtYmx5TWFuaWZlc3QgfSBmcm9tICcuL2Nsb3VkLWFzc2VtYmx5JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vICAgUkVBRCBUSElTIEZJUlNUIFdIRU4gQ0hBTkdJTkcgVEhJUyBGSUxFXG4vL1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vIFlvdSBuZWVkIChhbmQgb25seSBuZWVkKSB0byBidW1wIHRoZSBDTE9VRF9BU1NFTUJMWV9WRVJTSU9OIGlmIHRoZSBjbG91ZFxuLy8gYXNzZW1ibHkgbmVlZHMgbmV3IGZlYXR1cmVzIGZyb20gdGhlIENESyBDTEkuIEV4YW1wbGVzOiBuZXcgZmllbGRzLCBuZXdcbi8vIGJlaGF2aW9yLCBuZXcgYXJ0aWZhY3QgdHlwZXMuXG4vL1xuLy8gSWYgdGhhdCBoYXBwZW5zLCB5b3Ugc2V0IHRoZSBDTE9VRF9BU1NFTUJMWV9WRVJTSU9OIHRvIHRoZSAqbmV4dCogKG5vdCB0aGVcbi8vIGN1cnJlbnQhKSBDREsgdmVyc2lvbiB0aGF0IHdpbGwgYmUgcmVsZWFzZWQuIFRoaXMgaXMgZG9uZSB0byBwcm9kdWNlXG4vLyB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4vL1xuLy8gV2hlbiB5b3UgZG8gdGhpcywgeW91IHdpbGwgZm9yY2UgdXNlcnMgb2YgYSBuZXcgbGlicmFyeSB0byB1cGdyYWRlIHRoZSBDTElcbi8vIChnb29kKSwgYnV0IFVOTEVTUyBZT1UgQUxTTyBJTVBMRU1FTlQgJ3VwZ3JhZGVBc3NlbWJseU1hbmlmZXN0JyB5b3Ugd2lsbCBhbHNvXG4vLyBmb3JjZSBwZW9wbGUgd2hvIGhhdmUgaW5zdGFsbGVkIGEgbmV3ZXIgQ0xJIHRvIHVwZ3JhZGUgdGhlaXIgbGlicmFyaWVzIChiYWQhKS5cbi8vIERvIHRoYXQgdG9vLCB1bmxlc3MgeW91IGhhdmUgYSB2ZXJ5IGdvb2QgcmVhc29uIG5vdCB0by5cblxuLyoqXG4gKiBCdW1wIHRoaXMgdG8gdGhlIGxpYnJhcnkgdmVyc2lvbiBpZiBhbmQgb25seSBpZiB0aGUgQ1ggcHJvdG9jb2wgY2hhbmdlcy5cbiAqXG4gKiBXZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCAxLCAyLCAzLCAuLi4gaGVyZSB0byBpbmRpY2F0ZSBwcm90b2NvbCB2ZXJzaW9ucywgYnV0XG4gKiB0aG9zZSB0aGVuIHN0aWxsIG5lZWQgdG8gYmUgbWFwcGVkIHRvIHNvZnR3YXJlIHZlcnNpb25zIHRvIGJlIHVzZWZ1bC4gU28gd2VcbiAqIG1pZ2h0IGFzIHdlbGwgdXNlIHRoZSBzb2Z0d2FyZSB2ZXJzaW9uIGFzIHByb3RvY29sIHZlcnNpb24gYW5kIGltbWVkaWF0ZWx5XG4gKiBnZW5lcmF0ZSBhIHVzZWZ1bCBlcnJvciBtZXNzYWdlIGZyb20gdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHZlcnNpb25zIGFyZSBub3QgY29tcGFyZWQgaW4gYSBzZW12ZXIgd2F5LCB0aGV5IGFyZSB1c2VkIGFzXG4gKiBvcGFxdWUgb3JkZXJlZCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBDTE9VRF9BU1NFTUJMWV9WRVJTSU9OID0gJzEuMTYuMCc7XG5cbi8qKlxuICogTG9vayBhdCB0aGUgdHlwZSBvZiByZXNwb25zZSB3ZSBnZXQgYW5kIHVwZ3JhZGUgaXQgdG8gdGhlIGxhdGVzdCBleHBlY3RlZCB2ZXJzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlNYW5pZmVzdFZlcnNpb24obWFuaWZldFZlcnNpb246IHN0cmluZykge1xuICBjb25zdCBmcmFtZXdvcmtWZXJzaW9uID0gcGFyc2VTZW12ZXIobWFuaWZldFZlcnNpb24pO1xuICBjb25zdCB0b29sa2l0VmVyc2lvbiA9IHBhcnNlU2VtdmVyKENMT1VEX0FTU0VNQkxZX1ZFUlNJT04pO1xuXG4gIC8vIGlmIGZyYW1ld29yayA+IGNsaSwgd2UgcmVxdWlyZSBhIG5ld2VyIGNsaSB2ZXJzaW9uXG4gIGlmIChzZW12ZXIuZ3QoZnJhbWV3b3JrVmVyc2lvbiwgdG9vbGtpdFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIG5ld2VyIHZlcnNpb24gb2YgdGhlIENESyBDTEkgKD49ICR7ZnJhbWV3b3JrVmVyc2lvbn0pIGlzIG5lY2Vzc2FyeSB0byBpbnRlcmFjdCB3aXRoIHRoaXMgYXBwYCk7XG4gIH1cblxuICAvLyBpZiBmcmFtZXdvcmsgPCBjbGksIHdlIHJlcXVpcmUgYSBuZXdlciBmcmFtZXdvcmsgdmVyc2lvblxuICBpZiAoc2VtdmVyLmx0KGZyYW1ld29ya1ZlcnNpb24sIHRvb2xraXRWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIENESyBDTEkgeW91IGFyZSB1c2luZyByZXF1aXJlcyB5b3VyIGFwcCB0byB1c2UgQ0RLIG1vZHVsZXMgd2l0aCB2ZXJzaW9uID49ICR7Q0xPVURfQVNTRU1CTFlfVkVSU0lPTn1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZ3JhZGUgb2xkIG1hbmlmZXN0IHZlcnNpb25zIHRvIGxhdGVyIG1hbmlmZXN0IHZlcnNpb24gaGVyZSAoaWYgcG9zc2libGUpLlxuICpcbiAqIFVzZSB0aGlzIHRvIG1ha2UgdGhlIHRvb2xraXQgcmVjb2duaXplIG9sZCBhc3NlbWJseSB2ZXJzaW9ucy4gVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAqIGFkZCBuZXdseSByZXF1aXJlZCBmaWVsZHMgd2l0aCBhcHByb3ByaWF0ZSBkZWZhdWx0IHZhbHVlcywgZXRjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBncmFkZUFzc2VtYmx5TWFuaWZlc3QobWFuaWZlc3Q6IEFzc2VtYmx5TWFuaWZlc3QpOiBBc3NlbWJseU1hbmlmZXN0IHtcblxuICBpZiAobWFuaWZlc3QudmVyc2lvbiA9PT0gJzAuMzYuMCcpIHtcbiAgICAvLyBBZGRpbmcgYSBuZXcgYXJ0aWZhY3QgdHlwZSwgb2xkIHZlcnNpb24gd2lsbCBub3QgaGF2ZSBpdCBzbyBwYWlubGVzcyB1cGdyYWRlLlxuICAgIG1hbmlmZXN0ID0ganVzdFVwZ3JhZGVWZXJzaW9uKG1hbmlmZXN0LCAnMS4xMC4wJyk7XG4gIH1cblxuICBpZiAobWFuaWZlc3QudmVyc2lvbiA9PT0gJzEuMTAuMCcpIHtcbiAgICAvLyBUd28gY2hhbmdlczpcbiAgICAvLyAqIEJhY2t3YXJkcy1jb21wYXRpYmxlIGNoYW5nZXMgdG8gdGhlIFZQQyBwcm92aWRlclxuICAgIC8vICogQWRkZWQgQU1JIGNvbnRleHQgcHJvdmlkZXI6IG9sZCBhc3NlbWJsaWVzIHdvbid0IHJlZmVyZW5jZSBpdC5cbiAgICBtYW5pZmVzdCA9IGp1c3RVcGdyYWRlVmVyc2lvbihtYW5pZmVzdCwgJzEuMTYuMCcpO1xuICB9XG5cbiAgcmV0dXJuIG1hbmlmZXN0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlbXZlcih2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3QgdmVyID0gc2VtdmVyLmNvZXJjZSh2ZXJzaW9uKTtcbiAgaWYgKCF2ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBcIiR7dmVyc2lvbn1cIiBhcyBzZW12ZXJgKTtcbiAgfVxuXG4gIHJldHVybiB2ZXI7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgbWFuaWZlc3Qgd2l0aCBqdXN0IHRoZSB2ZXJzaW9uIGZpZWxkIHVwZGF0ZWRcbiAqXG4gKiBVc2VmdWwgaWYgdGhlcmUgYXJlIHByb3RvY29sIGNoYW5nZXMgdGhhdCBhcmUgYXV0b21hdGljYWxseSBiYWNrd2FyZHNcbiAqIGNvbXBhdGlibGUuXG4gKi9cbmZ1bmN0aW9uIGp1c3RVcGdyYWRlVmVyc2lvbihtYW5pZmVzdDogQXNzZW1ibHlNYW5pZmVzdCwgdmVyc2lvbjogc3RyaW5nKTogQXNzZW1ibHlNYW5pZmVzdCB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtYW5pZmVzdCwgeyB2ZXJzaW9uIH0pO1xufVxuIl19